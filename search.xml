<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop配置</title>
    <url>/Hadoop%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、<img src="/images/2020/07/03/89c58bcb-7005-4107-963a-4818a9d87378.png" alt="image.png"></h1><p><img src="/images/2020/07/03/f985fbbe-cc19-4f1b-a070-1a3a63e19ff1.png" alt="image.png"></p>
<h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、<img src="/images/2020/07/03/27f61d1d-9f53-4e81-8fd0-919147ce889b.png" alt="image.png"></h1><p><img src="/images/2020/07/03/dd0f5b09-389c-4229-a41f-a867c3b300ae.png" alt="image.png"><br><strong>2.关闭防火墙</strong><br><img src="/images/2020/07/03/cb331296-db7d-4d9b-bec1-64a54b42da28.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/741a605e-d70c-42fc-8d66-5bfe7a9311ed.png" alt="image.png"></p>
<p><strong>3.配置虚拟机网络环境</strong><br><img src="/images/2020/07/03/65ce14e7-e0b3-4082-be24-e043e7340899.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/0a7320b4-c498-4274-b734-587f01c7de88.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/0d9213d0-e906-45b3-b832-98e643952669.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/80a16bac-af4a-45d8-b2ee-6f7e1ed0418a.png" alt="image.png"></p>
<h1 id="三-xshell安装配置"><a href="#三-xshell安装配置" class="headerlink" title="三.xshell安装配置"></a>三.xshell安装配置</h1><p><img src="/images/2020/07/03/f2747501-d293-4a5c-ba13-e917d75fa80b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/5537a7b9-5318-48e5-b6bc-82b63da3b404.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/b1315770-6265-42ec-a459-678debd94a41.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/65d91729-d99d-44e9-8d09-6e869de69356.png" alt="image.png"></p>
<h1 id="四-JDK安装配置"><a href="#四-JDK安装配置" class="headerlink" title="四.JDK安装配置"></a>四.JDK安装配置</h1><p><img src="/images/2020/07/03/d3e5a86f-ec54-4d76-a781-f939cdef09cf.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/75113af8-934b-4fb7-86c0-588c4ce6e524.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/f973a403-bb87-458e-8dae-e0b3666b1fff.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/ef6eae9d-a980-45e1-a01b-a04fea19d6b2.png" alt="image.png"></p>
<h1 id="五、Hadoop安装配置"><a href="#五、Hadoop安装配置" class="headerlink" title="五、Hadoop安装配置"></a>五、Hadoop安装配置</h1><p><img src="/images/2020/07/03/6a52d7e2-cf40-408d-be84-6b18b43d4fb7.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/5e81d27a-55c5-485d-bec9-0e7b42300813.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/70d01996-1827-4561-a175-19079df584fd.png" alt="image.png"></p>
<h4 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h4><p><img src="/images/2020/07/03/eab231bb-6918-49bc-800b-74e93d064514.png" alt="image.png"><br><img src="/images/2020/07/03/bd956cd4-97f9-4b2a-9c93-0ff306de3a84.png" alt="image.png"><br><img src="/images/2020/07/03/e14d4b26-08e3-457d-9379-82ead80d0b84.png" alt="image.png"><br><img src="/images/2020/07/03/550b467b-2ad8-4785-8fd8-275fbd22ffc6.png" alt="image.png"><br><img src="/images/2020/07/03/dc88e51b-0b47-4358-a9d9-d839fcfff117.png" alt="image.png"><br><img src="/images/2020/07/03/3ac3e723-5b7d-45e2-a8c4-a73e4a2f8c54.png" alt="image.png"></p>
<h4 id="格式化DFS分布式文件系统"><a href="#格式化DFS分布式文件系统" class="headerlink" title="格式化DFS分布式文件系统"></a>格式化DFS分布式文件系统</h4><p><img src="/images/2020/07/03/43b01c4e-f227-4965-b221-6af47634f160.png" alt="image.png"></p>
<h4 id="启动Hadoop服务"><a href="#启动Hadoop服务" class="headerlink" title="启动Hadoop服务"></a>启动Hadoop服务</h4><p><img src="/images/2020/07/03/939ff4bc-620e-431e-a070-295b05ae84e0.png" alt="image.png"><br><img src="/images/2020/07/03/94247f8b-ab5e-4f67-ab94-805130f28788.png" alt="image.png"></p>
<h4 id="Hadoop-hdfs文件系统操作"><a href="#Hadoop-hdfs文件系统操作" class="headerlink" title="Hadoop hdfs文件系统操作"></a>Hadoop hdfs文件系统操作</h4><p><img src="/images/2020/07/03/50368444-86f5-45ec-90c4-8155bf8ca5ae.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/fe28a1ed-65be-4a3f-b791-55834035d74e.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/faf00ca8-5a99-452b-85b8-4229aa4c569b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/32f4b62a-a867-4bc7-84da-29a052a96b6b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/94b59784-cede-432e-bd6a-91c82ac4f99b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/d401bf31-4875-4580-9336-8c5c313a94ca.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/903ab773-cb5f-49ff-b3b5-7e2e7862491b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/1bed0a03-6033-440b-8880-9818b00e1f76.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/3ec18416-3119-49b3-9333-92c9222deb51.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/6a696449-91d9-4673-9355-a2dc5969869b.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/a779d505-232a-4f21-9c45-4ee1ccd90ace.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/167c54dd-32a4-426b-8973-3b2b10ea1eb8.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/337cd306-0f2d-4063-84f1-806c94553baf.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/03bbce7d-073d-4669-84f6-98e249087cfa.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/3ff071fa-cc6d-41c2-a0bd-ffc4b1573fcd.png" alt="image.png"></p>
<h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p><img src="/images/2020/07/03/b9982165-48e0-493c-8c77-8c7c6f96e542.png" alt="image.png"></p>
<p><img src="/images/2020/07/03/14dbd06e-e52b-4883-b01b-5682999c7b2f.png" alt="image.png">)<img src="/images/2020/07/03/b87a4719-92df-45cd-8382-74326e34128d.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive部署</title>
    <url>/Hive%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h1><p><img src="/images/2020/07/04/32c23f68-7a62-45ac-a037-45d0637446c9.png" alt="image.png"></p>
<h1 id="2、设置环境变量"><a href="#2、设置环境变量" class="headerlink" title="2、设置环境变量"></a>2、设置环境变量</h1><p><img src="/images/2020/07/04/b588bf95-83d8-47b1-bac5-35c17b11b09f.png" alt="image.png"></p>
<h1 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h1><p><img src="/images/2020/07/04/a19daca3-5db6-4f3e-9898-7272f9eb0cc1.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/6b6ca0f5-17b4-4f60-b32c-f294591618d5.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/590acc3d-4d5c-4e8d-b5d0-212f37219230.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/14573a1b-e560-4b9b-a6e6-e5192b1ebf8f.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/f8ee6630-cf61-4e30-ae2a-a42aa1453d0e.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/a1bdd668-39a3-4fa5-b720-b95a5b331498.png" alt="image.png"></p>
<p><img src="/images/2020/07/04/5be6617f-223b-44a0-98d4-7dc47ef5d55b.png" alt="image.png"><br>ive</p>
<h1 id="4、初始化元数据库"><a href="#4、初始化元数据库" class="headerlink" title="4、初始化元数据库"></a>4、初始化元数据库</h1><p><img src="/images/2020/07/04/845cd393-33cd-4261-8621-6cd22f1b9a9a.png" alt="image.png"></p>
<h1 id="5、启动Hive"><a href="#5、启动Hive" class="headerlink" title="5、启动Hive"></a>5、启动Hive</h1><p><img src="/images/2020/07/04/d485b0c7-c205-48b2-a8d0-de4cee435270.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HIve</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查看硬件信息</title>
    <url>/Linux%E6%9F%A5%E7%9C%8B%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # uname -a               # 查看内核&#x2F;操作系统&#x2F;CPU信息</span><br><span class="line">2. # head -n 1 &#x2F;etc&#x2F;issue   # 查看操作系统版本</span><br><span class="line">3. # cat &#x2F;proc&#x2F;cpuinfo      # 查看CPU信息</span><br><span class="line">4. # hostname               # 查看计算机名</span><br><span class="line">5. # lspci -tv              # 列出所有PCI设备（yum install pciutils）</span><br><span class="line">6. # lsusb -tv              # 列出所有USB设备</span><br><span class="line">7. # lsmod                  # 列出加载的内核模块</span><br><span class="line">8. # env                    # 查看环境变量</span><br></pre></td></tr></table></figure>
<p>资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # free -m                # 查看内存使用量和交换区使用量</span><br><span class="line">2. # df -h                  # 查看各分区使用情况</span><br><span class="line">3. # du -sh &lt;目录名&gt;        # 查看指定目录的大小</span><br><span class="line">4. # grep MemTotal &#x2F;proc&#x2F;meminfo   # 查看内存总量</span><br><span class="line">5. # grep MemFree &#x2F;proc&#x2F;meminfo    # 查看空闲内存量</span><br><span class="line">6. # uptime                 # 查看系统运行时间、用户数、负载</span><br><span class="line">7. # cat &#x2F;proc&#x2F;loadavg      # 查看系统负载</span><br></pre></td></tr></table></figure>
<p>磁盘和分区</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # mount | column -t      # 查看挂接的分区状态</span><br><span class="line">2. # fdisk -l               # 查看所有分区</span><br><span class="line">3. # swapon -s              # 查看所有交换分区</span><br><span class="line">4. # hdparm -i &#x2F;dev&#x2F;hda     # 查看磁盘参数(仅适用于IDE设备)</span><br><span class="line">5. # dmesg | grep IDE       # 查看启动时IDE设备检测状况</span><br></pre></td></tr></table></figure>

<p>网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # ifconfig               # 查看所有网络接口的属性</span><br><span class="line">2. # iptables -L            # 查看防火墙设置</span><br><span class="line">3. # route -n               # 查看路由表</span><br><span class="line">4. # netstat -lntp          # 查看所有监听端口</span><br><span class="line">5. # netstat -antp          # 查看所有已经建立的连接</span><br><span class="line">6. # netstat -s             # 查看网络统计信息</span><br></pre></td></tr></table></figure>

<p>进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -ef                 # 查看所有进程</span><br><span class="line"># top                    # 实时显示进程状态</span><br></pre></td></tr></table></figure>




<p>用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># w                      # 查看活动用户</span><br><span class="line"># id &lt;用户名&gt;            # 查看指定用户信息</span><br><span class="line"># last                   # 查看用户登录日志</span><br><span class="line"># cut -d: -f1 &#x2F;etc&#x2F;passwd   # 查看系统所有用户</span><br><span class="line"># cut -d: -f1 &#x2F;etc&#x2F;group    # 查看系统所有组</span><br><span class="line"># crontab -l             # 查看当前用户的计划任务</span><br></pre></td></tr></table></figure>




<p>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # chkconfig --list       # 列出所有系统服务</span><br><span class="line">2. # chkconfig --list | grep on    # 列出所有启动的系统服务</span><br></pre></td></tr></table></figure>




<p>程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # rpm -qa                # 查看所有安装的软件包</span><br></pre></td></tr></table></figure>

<p>查看网卡型号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lspci | grep Ethernet</span><br></pre></td></tr></table></figure>

<p>查看内存和cpu最直接最常用的命令</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. # free</span><br><span class="line">2. # cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>

<p>查看硬盘信息（查看硬盘型号和硬盘序列号）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df -h</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 浏览器扩展神器暴力猴</title>
    <url>/Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E7%A5%9E%E5%99%A8%E6%9A%B4%E5%8A%9B%E7%8C%B4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>我平常工作最常用的浏览器就是 Chrome 了，Google 出品，值得信赖，用 Chrome 就不得不提浏览器扩展了，有了各种 Chrome 扩展，可以让你浏览器网页更方便，工作更高效。<br>Chrome 扩展可以在 Google 应用商店下载<a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN这里可以搜索安装你喜欢的各种扩展。" target="_blank" rel="noopener">https://chrome.google.com/webstore/category/extensions?hl=zh-CN这里可以搜索安装你喜欢的各种扩展。</a><br><img src="/images/2020/07/06/8524a9de-6cd2-4bd9-8540-939cd94f9e25.png" alt="image.png"><br>比如我装了很多扩展。<img src="/images/2020/07/06/7b140c9e-c0a3-4f05-becc-34c96ffa092d.png" alt="image.png"><br>扩展这么多，其中的油猴<a href="Tampermonkey">Tampermonkey</a> 是必须推荐的一个，它是扩展中的王者，最强大的浏览器扩展。</p>
<h3 id="安装暴力猴扩展"><a href="#安装暴力猴扩展" class="headerlink" title="安装暴力猴扩展"></a>安装暴力猴扩展</h3><p>可以在谷歌商店直接安装<a href="https://chrome.google.com/webstore/detail/violentmonkey/jinjaccalgkegednnccohejagnlnfdag?hl=zh-CN" target="_blank" rel="noopener">暴力猴</a><img src="/images/2020/07/06/e9021617-1ff3-495d-b62b-8a872b985f20.png" alt="image.png"><br>也可以再扩展迷下载<a href="https://www.extfans.com/productivity/jinjaccalgkegednnccohejagnlnfdag" target="_blank" rel="noopener">暴力猴</a><br><img src="/images/2020/07/06/7763c5c1-ef7d-4733-b2ca-9e34b81065af.png" alt="image.png"><br>如果上不了Google，可以在国内第三方Chrome 插件网站<br><a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">https://www.crx4chrome.com/</a><br><a href="http://chromecj.com/" target="_blank" rel="noopener">http://chromecj.com/</a><br><a href="http://www.cnplugins.com/" target="_blank" rel="noopener">http://www.cnplugins.com/</a><br><a href="https://www.chromefor.com/" target="_blank" rel="noopener">https://www.chromefor.com/</a><br>等搜索下载。下载的是个 crx 文件，然后打开 Chrome 扩展chrome://extensions/，打开开发者模式，将下载的crx文件拖进去，如果出错提示程序包无效。<br><img src="/images/2020/07/06/3877d52f-f1ad-4602-8f54-5ec4ffd317fd.png" alt="image.png"><br>将 crx 后缀改为 zip 再拖进去就能安装成功了，浏览器右上角可以看到图标。<img src="/images/2020/07/06/c3c6cef5-c7c5-4a2a-8ada-ac6fff1ee0a8.png" alt="image.png"></p>
<h3 id="脚本网站"><a href="#脚本网站" class="headerlink" title="脚本网站"></a>脚本网站</h3><p>有了暴力猴扩展，还需要配上脚本。<br>安装完扩展后点击图标，选择 获取新脚本<br>会进入网站<a href="https://www.tampermonkey.net/scripts.php" target="_blank" rel="noopener">https://www.tampermonkey.net/scripts.php</a><br>这里可以获取脚本来源，有3个来源网站<br><a href="http://userscripts-mirror.org/" target="_blank" rel="noopener">http://userscripts-mirror.org/</a><br><a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a><br><a href="https://greasyfork.org/" target="_blank" rel="noopener">https://greasyfork.org/</a><br>这里推荐 greasyfork ，因为它支持中文。</p>
<p>打开网站首页<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">https://greasyfork.org/zh-CN</a> 可以看到很多脚本。<img src="/images/2020/07/06/4307fa08-a4ac-4e5a-a0e2-e7f98cd80765.png" alt="image.png">安装脚本也很简单，找到需要的脚本，进入页面，点击安装，然后管理面板即可看到已安装的脚本。</p>
<p>下面推荐些实用的脚本，开始打开新世界的大门。</p>
<h4 id="搜索去广告"><a href="#搜索去广告" class="headerlink" title="搜索去广告"></a>搜索去广告</h4><p>功能介绍：<br>去掉百度、搜狗、谷歌搜索结果的重定向，回归为网站的原始网址—附带有去除百度的广告 包括百度顶部和底部的垃圾广告，脚本地址<a href="https://greasyfork.org/zh-CN/scripts/14178" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/14178</a></p>
<p>安装脚本前搜索 浏览器 前面3个是广告<img src="/images/2020/07/06/62003585-644d-4bd4-a899-b3821ccfc40b.png" alt="image.png">)安装脚本后的效果，广告没有了，你还可以自定义设置。<img src="/images/2020/07/06/c22f76d3-5a21-43fa-b3cc-7b6b0237e47e.png" alt="image.png"></p>
<h4 id="知乎网页助手"><a href="#知乎网页助手" class="headerlink" title="知乎网页助手"></a>知乎网页助手</h4><p>功能介绍：<br>1、知乎站外链接直接跳转至目标网址；<br>2、自动展开问题全部信息，同时展示所有回答；<br>3、去除知乎网页中的广告；<br>4、知乎网页中短视频下载；<br>5、解除知乎复制限制-划词复制（鼠标左键划词自动添加到剪切板）</p>
<p>脚本地址 <a href="https://greasyfork.org/zh-CN/scripts/384172" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/384172</a></p>
<p>比如这个周杰伦的视频回答 <a href="https://www.zhihu.com/question/35123246/answer/585795363" target="_blank" rel="noopener">https://www.zhihu.com/question/35123246/answer/585795363</a><br>安装脚本前<img src="/images/2020/07/06/f64e33d3-7f79-4570-b208-7a335dc3976a.png" alt="image.png">)安装后视频可以直接下载了。<img src="/images/2020/07/06/17bf28b9-2213-4443-90a5-3805ecd077a2.png" alt="image.png"></p>
<h4 id="全网VIP视频免费破解"><a href="#全网VIP视频免费破解" class="headerlink" title="全网VIP视频免费破解"></a>全网VIP视频免费破解</h4><p>功能介绍：<br>懒人专用，全网VIP视频免费破解去广告、全网音乐直接下载、百度网盘直接下载、知乎视频下载等多合一版。<br>脚本地址<a href="https://greasyfork.org/zh-CN/scripts/370634" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/370634</a></p>
<p>打开优酷看《 长安十二时辰》，16集开始需要VIP<a href="https://v.youku.com/v_show/id_XNDI2NTAzNzQzNg==.html![image.png](/images/2020/07/06/8e985a7b-ed25-4744-b70d-0c4d784406ae.png)安装脚本后，点击左侧的VIP可以跳转到VIP解析网站观看。![image.png](/images/2020/07/06/4a667e1e-ef18-483c-baa7-b0821f256fdd.png)![image.png](/images/2020/07/06/3f377402-00cc-4fda-8c52-63070bfb8d1f.png)" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDI2NTAzNzQzNg==.html![image.png](/images/2020/07/06/8e985a7b-ed25-4744-b70d-0c4d784406ae.png)安装脚本后，点击左侧的VIP可以跳转到VIP解析网站观看。![image.png](/images/2020/07/06/4a667e1e-ef18-483c-baa7-b0821f256fdd.png)![image.png](/images/2020/07/06/3f377402-00cc-4fda-8c52-63070bfb8d1f.png)</a><br>如果看不了，换接口解析。<img src="/images/2020/07/06/6474c638-585e-41d0-875b-5d30f07683ea.png" alt="image.png"></p>
<h4 id="豆瓣资源下载大师"><a href="#豆瓣资源下载大师" class="headerlink" title="豆瓣资源下载大师"></a>豆瓣资源下载大师</h4><p>功能介绍：<br>聚合数百家资源网站，通过右侧边栏1秒告诉你哪些网站能下载豆瓣页面上的电影|电视剧|纪录片|综艺|动画|音乐|图书等，有资源的网站显示绿色，没资源的网站显示黄色，就这么直观。</p>
<p>脚本地址 <a href="https://greasyfork.org/zh-CN/scripts/329484" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/329484</a></p>
<p>看看最近上映的电影《蜘蛛侠：英雄远征》 <a href="https://movie.douban.com/subject/26931786/?from=showing" target="_blank" rel="noopener">https://movie.douban.com/subject/26931786/?from=showing</a><br>右侧可以看到 中文影视字幕和影视精准匹配，可以到对应网站查看。</p>
<p><img src="/images/2020/07/06/556df42d-3f60-4f3c-b929-c2b8c97870ed.png" alt="image.png">更多其他脚本自己搜索吧，有什么问题可以评论交流。</p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>暴力猴</tag>
      </tags>
  </entry>
  <entry>
    <title>Python开发者必备的神器----pycharm</title>
    <url>/Python%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84%E7%A5%9E%E5%99%A8-pycharm.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>众所周知，Python语言是当下最热门的编程语言，广泛应用于数据分析、爬虫、机器学习等领域，当然了，IDE首选pychram了。Python编程语言是由荷兰计算机程序员von Rosen于1991年设计的。面向对象，解释器，高级和通用这种编程语言的特性是可读性和编写程序从其生产目标中相当好的可读性。JetBrains PyCharm Professional是最好的Python开发环境之一，在编辑，故障排除和纠正，自动完成等方面具有出色的能力和智能。</p>
<p>不多哔哔了，直接进入主题！<img src="/images/2020/07/06/4b5b7a04-fdb2-47a9-b4c8-7fb0bcd64359.png" alt="image.png"></p>
<h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>1、编码协助<br>PyCharm Pro 2020提供了一个带编码补全，代码片段，支持代码折叠和分割窗口的智能、可配置的编辑器，可帮助用户更快更轻松的完成编码工作。<br>2、项目代码导航<br>该IDE可帮助用户即时从一个文件导航至另一个，从一个方法至其申明或者用法甚至可以穿过类的层次。若用户学会使用其提供的快捷键的话甚至能更快。<br>3、代码分析<br>用户可使用其编码语法，错误高亮，智能检测以及一键式代码快速补全建议，使得编码更优化。<br>4、Python重构<br>有了该功能，用户便能在项目范围内轻松进行重命名，提取方法/超类，导入域/变量/常量，移动和前推/后退重构。<br>5、支持Django<br>有了它自带的HTML,CSS和 JavaScript编辑器 ，用户可以更快速的通过Djang框架进行Web开发。此外，其还能支持CoffeeScript, Mako 和 Jinja2。<br>6、支持Google App引擎<br>用户可选择使用Python 2.5或者2.7运行环境，为Google APp引擎进行应用程序的开发，并执行例行程序部署工作。<br>7、集成版本控制<br>登入，录出，视图拆分与合并–所有这些功能都能在其统一的VCS用户界面(可用于Mercurial, Subversion, Git, Perforce 和其他的 SCM)中得到。<br>8、图形页面调试器<br>用户可以用其自带的功能全面的调试器对Python或者Django应用程序以及测试单元进行调整，该调试器带断点，步进，多画面视图，窗口以及评估表达式。<br>9、集成的单元测试<br>用户可以在一个文件夹运行一个测试文件，单个测试类，一个方法或者所有测试项目。<br>10、可自定义&amp;可扩展<br>可绑定了 Textmate, NetBeans, Eclipse &amp; Emacs 键盘主盘，以及 Vi/Vim仿真插件。</p>
<h1 id="安装破解教程："><a href="#安装破解教程：" class="headerlink" title="安装破解教程："></a>安装破解教程：</h1><p>1.先下载安装包和破解补丁压缩包，然后安装安装包，启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE；</p>
<p>官方安装包链接：<a href="https://download.jetbrains.com/python/pycharm-professional-2020.1.exe?_ga=2.189228526.416209632.1587296965-1436667435.1584533140" target="_blank" rel="noopener">https://download.jetbrains.8686c.com/python/pycharm-professional-2020.1.exe?_ga=2.189228526.416209632.1587296965-1436667435.1584533140</a><br>2.下载破解补丁压缩包解压后得到jetbrains-agent.jar。<br>下载页面（点击普通下载即可）：<a href="https://pan.baidu.com/s/1v102Y3iLqvgqSk-3QtaTjQ" target="_blank" rel="noopener">链接</a>：<br>提取码：73ao<br>3. 启动你的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。<br>如果你的IDE试用已过期可以使用reset_eval文件夹内的脚本重置一下。<img src="/images/2020/07/06/40dfdeae-98d7-416a-a8ae-313752712d07.png" alt="image.png"><br>4. 将 jetbrains-agent.jar 拖进IDE窗口（或者当作IDE插件安装），点 “Restart” 按钮重启IDE。<br>（第二种方法，事实上你拖 jetbrains-agent-latest.zip 进去IDE窗口也没问题）<img src="/images/2020/07/06/ebfc0887-a2ff-4087-a12d-2d2c472fdd3d.png" alt="image.png"><br><img src="/images/2020/07/06/3eabb124-f4bf-4a63-b8e8-e44c83b2d78d.png" alt="image.png">更详细的具体使用方法已写在压缩包的 README.pdf / README.txt内，也可以忽视README.pdf / README.txt。<br>5.弹出激活方式，选择activation code后，点击为PyCharm安装，然后再点击是重启软件。<img src="/images/2020/07/06/46aa500c-0d5c-4669-9ef6-a0a8caae2c52.png" alt="image.png"><br>6.重启IDE，搞定，完美破解。<br><img src="/images/2020/07/06/b646d010-8933-4453-ae85-f28922315dd5.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop编程入门</title>
    <url>/Hadoop%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>Hadoop编程入门</p>
<p>一、准备软件<br>（1）IntelliJ IDEA Community<br><a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/#section=windows</a>!<br>（2）Hadoop<br><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener">https://hadoop.apache.org/releases.html</a><br>（3）Winutils<br>链接：<a href="https://pan.baidu.com/s/15xizRvY17-m-gqPH5YapXw" target="_blank" rel="noopener">https://pan.baidu.com/s/15xizRvY17-m-gqPH5YapXw</a><br>提取码：qw0j<br>（4）Java JDK 1.8<br>链接：<a href="https://pan.baidu.com/s/1hMad9dATs3MpZka3QXgIZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1hMad9dATs3MpZka3QXgIZA</a><br>提取码：q59l</p>
<p>二、安装软件<br>（1）IntelliJ IDEA Community<br><img src="/images/2020/07/12/b475d6f2-87e0-469f-82a8-4ac25dc582bf.png" alt="image.png"><br>（2）Hadoop解压到D盘<br> <img src="/images/2020/07/12/219edf4c-0daf-4a68-8839-69767e0661ce.png" alt="image.png"></p>
<p>并配置环境变量</p>
<p> <img src="/images/2020/07/12/4160701e-7f76-4b1f-b8bb-15c6b52f793f.png" alt="image.png">)<img src="/images/2020/07/12/ae2d738b-fe84-4ecb-a99a-0464468bffcb.png" alt="image.png"></p>
<p>（3）将winutils解压后放到hadoop目录中的bin下面<br><img src="/images/2020/07/12/7549f2db-b6fc-4e6a-aba4-9048e15f6dfe.png" alt="image.png"></p>
<p>（4）JDK环境变量配置<br> <img src="/images/2020/07/12/2c6e8f90-2ea6-483d-bba0-72239a32283e.png" alt="image.png"><br> <img src="/images/2020/07/12/e10da524-6336-4c9a-8a0d-a4aefd573d96.png" alt="image.png"></p>
<p>三、创建项目<br>（1）创建maven项目<br> <img src="/images/2020/07/12/fe7a0e31-0442-4371-9f85-0dd8f2715432.png" alt="image.png"><br>为项目起名（mapreduce）<br> <img src="/images/2020/07/12/26be2c4f-7bad-4b44-83e3-6ac36c53f5cc.png" alt="image.png"><br> <img src="/images/2020/07/12/815f55dc-d203-42b5-b69a-8194bc696016.png" alt="image.png"><br>项目结构<br> <img src="/images/2020/07/12/7503a628-274e-45c6-be2b-79e07741a77b.png" alt="image.png"></p>
<p>（2）配置pom文件</p>
<p><img src="/images/2020/07/12/a759a198-0161-4353-96ee-877fcb513348.png" alt="image.png"><br>（3）创建WordCount程序<br> <img src="/images/2020/07/12/e3c7c10d-80ff-44fb-8e26-984d742f06c5.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.hmy.mr;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IntWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line">public class WordCount &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration conf &#x3D; new Configuration();</span><br><span class="line">        Job job &#x3D; Job.getInstance(conf, &quot;word count&quot;);</span><br><span class="line">        job.setJarByClass(WordCount.class);</span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">        job.setReducerClass(IntSumReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path(args[0]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, new Path(args[1]));</span><br><span class="line">        System.exit(job.waitForCompletion(true) ? 0 : 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">        private final static IntWritable one &#x3D; new IntWritable(1);</span><br><span class="line">        private Text word &#x3D; new Text();</span><br><span class="line"></span><br><span class="line">        public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            StringTokenizer itr &#x3D; new StringTokenizer(value.toString());</span><br><span class="line">            while (itr.hasMoreTokens()) &#123;</span><br><span class="line">                word.set(itr.nextToken());</span><br><span class="line">                context.write(word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">        private IntWritable result &#x3D; new IntWritable();</span><br><span class="line"></span><br><span class="line">        public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            int sum &#x3D; 0;</span><br><span class="line">            for (IntWritable val : values) &#123;</span><br><span class="line">                sum +&#x3D; val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>四、发布项目<br>（1）打jar包<br> <img src="/images/2020/07/12/5cc7aac1-7822-4c18-af72-939844181b43.png" alt="image.png"><br> <img src="/images/2020/07/12/1f92df2f-5bdb-4787-a3e1-80284f43997a.png" alt="image.png"><br>  <img src="/images/2020/07/12/404c79b4-933d-4c36-bdc4-17cf45b33e62.png" alt="image.png"><br><img src="/images/2020/07/12/78d7bcd1-ec45-44a3-abf1-890021c1dd2f.png" alt="image.png"><br><img src="/images/2020/07/12/2a8742b2-8a97-4862-9016-c03e429e4d68.png" alt="image.png">)<img src="/images/2020/07/12/bca695a1-1bab-4cff-83c4-3b367ecd4853.png" alt="image.png">)<img src="/images/2020/07/12/72eef7c6-0a52-464d-a9b5-0fd76d6d25e2.png" alt="image.png"><br>五、将jar包传到linux系统<br><img src="/images/2020/07/12/70ab359f-26c9-4052-ab46-cac1bdb5d24c.png" alt="image.png"><br> <img src="/images/2020/07/12/95e1c40c-ef03-49e4-b41b-b7ff7c61baa4.png" alt="image.png"></p>
<p>六、运行hadoop程序<br>（1） 首先在/opt/tools/下创建一个文件t，打开文件，里面任意输入几个单词<br>（2） 在hdfs上创建文件夹，使用此命令<br>hdfs dfs -mkdir /test<br>然后，将文件t上传到hdfs上，使用此命令<br>hdfs  dfs  -put  /opt/tools/t    /test</p>
<p>（3） 执行hadoop jar /opt/tools/mareduce.jar com.hmy.mr.WordCount /test/t /out/1<br><img src="/images/2020/07/12/8c56d9f9-84b8-4355-ba74-75f7e37895b5.png" alt="image.png"><br>  <img src="/images/2020/07/12/cdbfd0e3-0257-4883-95f1-2a9553df1624.png" alt="image.png"></p>
<p>最终结果</p>
<p><img src="/images/2020/07/12/5898fdb9-7c43-47b9-9b82-09446232f433.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin安装</title>
    <url>/deepin%E5%AE%89%E8%A3%85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>请确保您的电脑满足以下的配置要求，如果您的电脑配置低于以下要求，将无法完美地体验深度操作系统：</p>
<blockquote>
<p>段落引用处理器：Intel Pentium IV 2GHz 或更快的处理器<br>内存：至少 2G 内存(RAM)，4G 以上是达到更好性能的推荐值<br>硬盘：至少 25 GB 的空闲空间<br>您还需要一个U盘，或一张光盘以及光驱，然后在深度科技官方网站下载<a href="镜像文件"></a>并<a href="制作启动盘"></a>。</p>
</blockquote>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>一般情况下电脑默认是从硬盘启动，因此，在使用光盘安装系统之前，您需要先进入电脑的BIOS界面将光盘设置为第一启动项。</p>
<p>台式机一般为 Delete 键、笔记本一般为 F2  或 F10 或 F12 键，即可进入 BIOS 设置界面。</p>
<p>您只需在享受一杯咖啡的时间，便可完成系统的安装。</p>
<p>1、将深度操作系统光盘/U盘插入电脑光驱中。</p>
<p>2、启动电脑，将光盘/U盘设置为第一启动项。</p>
<p>3、进入安装界面，选择需要安装的语言。</p>
<p><img src="/images/2020/07/04/629ac412-4e54-4cf6-a353-531630ade225.png" alt="image.png"></p>
<p>4、进入账户界面，输入系统用户名和密码。</p>
<p><img src="/images/2020/07/04/4b80ef91-0e2f-4492-a20b-5a305214aa80.png" alt="image.png"></p>
<p>5、点击 下一步。</p>
<p>6、选择文件格式、挂载点、分配空间等。</p>
<p><img src="/images/2020/07/04/d1dbc8e9-d74f-4c5b-8cff-96ca242148ae.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>挂载点</th>
<th>挂载点中文名</th>
<th>文件系统</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>根分区（必选）</td>
<td>EXT4（推荐)</td>
<td>最少10G</td>
</tr>
<tr>
<td>/home</td>
<td>家目录（推荐）</td>
<td>EXT4（推荐）</td>
<td>最少10G</td>
</tr>
<tr>
<td>swap</td>
<td>交换分区（可选）</td>
<td>不设置</td>
<td>4G内存以下分配2G，4G以上可不分配</td>
</tr>
</tbody></table>
<p>7、点击 安装。</p>
<p>8、在弹出的确认安装窗口中，点击 确定。</p>
<p>9、将开始自动安装深度操作系统。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>mavern阿里云仓库设置</title>
    <url>/mavern%E9%98%BF%E9%87%8C%E4%BA%91%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>#第一步，右击项目名称<img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/20-5-4/1.png" alt=""><br>#第二步，创建setting.xml<img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/20-5-4/2.png" alt=""><br>#第三步，填上这些即可<img src="https://b-l.oss-cn-hongkong.aliyuncs.com/photos/20-5-4/3.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>python元组</title>
    <url>/python%E5%85%83%E7%BB%84.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="对于元组来说，元组和列表是差不多的"><a href="#对于元组来说，元组和列表是差不多的" class="headerlink" title="对于元组来说，元组和列表是差不多的"></a>对于元组来说，元组和列表是差不多的</h1><h1 id="元组是不能修改的，-比如不能增加元素，不能修改元素，不能删除元素，"><a href="#元组是不能修改的，-比如不能增加元素，不能修改元素，不能删除元素，" class="headerlink" title="元组是不能修改的， 比如不能增加元素，不能修改元素，不能删除元素，"></a>元组是不能修改的， 比如不能增加元素，不能修改元素，不能删除元素，</h1><h1 id="元组遍历"><a href="#元组遍历" class="headerlink" title="元组遍历"></a>元组遍历</h1><p>tu = (1,2,34,5)<br>for index,value in enumerate(tu):<br>    print(index,value)</p>
<h1 id="返回这个元素在对象中出现的次数"><a href="#返回这个元素在对象中出现的次数" class="headerlink" title="返回这个元素在对象中出现的次数"></a>返回这个元素在对象中出现的次数</h1><p>num = tu.count(2)<br>print(num)</p>
<h1 id="index-返回的是查找在列表中的下标"><a href="#index-返回的是查找在列表中的下标" class="headerlink" title="index 返回的是查找在列表中的下标"></a>index 返回的是查找在列表中的下标</h1><p>num2 = tu.index(34)<br>print(num2)</p>
<h1 id="类型相互转换"><a href="#类型相互转换" class="headerlink" title="============类型相互转换=========="></a>============类型相互转换==========</h1><h1 id="1、字典转换成元组"><a href="#1、字典转换成元组" class="headerlink" title="1、字典转换成元组"></a>1、字典转换成元组</h1><p>dict1 = {‘name’:1,”age”:23}</p>
<h1 id="如果直接tuple-dict1-那么返回的只是字典的keys"><a href="#如果直接tuple-dict1-那么返回的只是字典的keys" class="headerlink" title="如果直接tuple(dict1) 那么返回的只是字典的keys"></a>如果直接tuple(dict1) 那么返回的只是字典的keys</h1><p>tu1 = tuple(dict1.values())<br>print(tu1)</p>
<h1 id="字典转换成列表-list-dict1-那么返回的只是字典的keys"><a href="#字典转换成列表-list-dict1-那么返回的只是字典的keys" class="headerlink" title="字典转换成列表,list(dict1) 那么返回的只是字典的keys"></a>字典转换成列表,list(dict1) 那么返回的只是字典的keys</h1><p>li = list(dict1)<br>print(li)</p>
<p>li2 =list(dict1.values())<br>print(li2)</p>
<h1 id="2、字典转换成字符串"><a href="#2、字典转换成字符串" class="headerlink" title="2、字典转换成字符串"></a>2、字典转换成字符串</h1><p>str1 = str(dict1)<br>print(str1)<br>转字符串需不需要注意返回得是什么内容（关键字？values？）</p>
<h1 id="元组转换成字符串、列表-注意：元组不可以转为字典"><a href="#元组转换成字符串、列表-注意：元组不可以转为字典" class="headerlink" title="=====元组转换成字符串、列表====注意：元组不可以转为字典"></a>=====元组转换成字符串、列表====注意：元组不可以转为字典</h1><p>tupleExchang = (1,2,3,4,5,”a”)<br>str2 = tupleExchang.<strong>str</strong>()<br>print(type(str2))<br>print(str2)</p>
<p>list2 = list(tupleExchang)<br>print(list2)</p>
<h1 id="列表转换成字符串、元组-注意：列表不能转换成字典"><a href="#列表转换成字符串、元组-注意：列表不能转换成字典" class="headerlink" title="=======列表转换成字符串、元组======注意：列表不能转换成字典"></a>=======列表转换成字符串、元组======注意：列表不能转换成字典</h1><p>list3 = [1,2,34,55,6]<br>str3 = str(list3)<br>print(str3)</p>
<p>tup = tuple(list3)<br>print(tup)</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware workstation 不可恢复错误解决</title>
    <url>/VMware-workstation-%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>由于笔记本关机时，仍然在运行VMware里面的系统并没有正常的关机当再次开机时导致出现了如下错误<br><img src="/images/2020/07/03/7e7008af-facc-4262-8856-a853804d7bb5.png" alt="image.png">虚拟机是一种被挂起的状态，无法恢复到当时电脑关机时的状态。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>到虚拟机安装目录下删除掉一个文件即可<br><img src="/images/2020/07/03/5864f3e9-6530-4ada-8a1c-15e9fd6e51eb.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建个人博客</title>
    <url>/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在随着计算机的飞速发展，拥有一个属于自己的博客，是一件非常平常的事。使用hexo搭建一个属于自己的个人博客，是即快捷又美观的一种方式，也是非常受到人们的喜爱的。接下来我将带领大家一起搭建自己的博客。后续还有hexo的next主题美化，hexo的部署，hexo的百度录入等等，一系列的教程，你可以访问我的<a href="个人博客">个人博客</a>.</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<p>系统：window10专业版<br>nodejs：下载 <a href="点击这里快捷电梯">点击这里快捷电梯</a><br>git：下载 <a href="点击这里快捷电梯">点击这里快捷电梯</a></p>
</blockquote>
<h1 id="安装hexo运行环境"><a href="#安装hexo运行环境" class="headerlink" title="安装hexo运行环境"></a>安装hexo运行环境</h1><blockquote>
<p>安装是非常简单的，nodejs和git的安装是非常简单的。如果你实在不会就上网搜安装教程，会有很多的。</p>
</blockquote>
<p> nodejs安装完成后的检验操作是在das窗口下输入命令 node -v和npm -v这两个命令就是查看版本信息的。如下图所示:<br><img src="/images/2020/07/09/9af42f2f-c976-4c3f-b3a3-b7aec6c00893.png" alt="image.png"><br>​ git安装完成后的检验操作是：鼠标右键 效果如下图所示。<br><img src="/images/2020/07/09/7a8e4e90-a0f7-41ec-9037-bb8ccc0b881a.png" alt="image.png"></p>
<h1 id="安装hexo基本框架"><a href="#安装hexo基本框架" class="headerlink" title="安装hexo基本框架"></a>安装hexo基本框架</h1><h2 id="第一步：新建文件夹"><a href="#第一步：新建文件夹" class="headerlink" title="第一步：新建文件夹"></a>第一步：新建文件夹</h2><p>​ 这一步是为了给你的博客找一个合适的位置。新建的文件夹的命名是随意的。进入新建的文件夹后，鼠标右键点击Git Bash Here 。如下图。<br><img src="/images/2020/07/09/2d87cd8f-d84b-44cd-b66f-b31529a6ce40.png" alt="image.png"></p>
<h2 id="第二步：安装hexo基础框架"><a href="#第二步：安装hexo基础框架" class="headerlink" title="第二步：安装hexo基础框架"></a>第二步：安装hexo基础框架</h2><p> 第一步完成后，会出现一个命名窗口。输入如下命令：</p>
<figure class="highlight plain"><figcaption><span>这是安装hexo的基础框架</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>第五条命名完成后，可以首次体验一下，如下图<br><img src="/images/2020/07/09/fed0dc4a-81b4-4b1d-8220-f5779b2cc133.png" alt="image.png"><br>浏览器中的效果如下：<img src="/images/2020/07/09/d4c16782-4d0d-42e4-96cc-095b562e8bf3.png" alt="image.png"></p>
<h1 id="hexo的后续操作"><a href="#hexo的后续操作" class="headerlink" title="hexo的后续操作"></a>hexo的后续操作</h1><p>hexo的next主题美化，hexo的部署，hexo的百度录入等等，一系列的教程，你可以访问<a href="点击这里我的个人博客">点击这里我的个人博客</a>.</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/python%E5%87%BD%E6%95%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1、python3的map函数<br>map()函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator（迭代器）返回。<br>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x):<br>     return x * x<br>r = map(f, [1<em>1, 2</em>2, 3<em>3, 4, 5, 6, 7, 8, 9])<br>list(r)<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]<br>上述代码中f是一个map对象，r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。<br>不对r进行list函数的话，输出结果如下：<br>def f(n):<br>    return n</em>n<br>r = map(f,[1,2,3])<br>print(r)<br>结果：<br>&lt;map object at 0x000001FB4EC5D240&gt;<br>map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’]<br>2、python3的reduce函数<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<p>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br>比方说对一个序列求和，就可以用reduce实现：</p>
<blockquote>
<blockquote>
<blockquote>
<p>from functools import reduce<br>def add(x, y):<br>     return x + y<br>reduce(add, [1, 3, 5, 7, 9])<br>25<br>字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from functools import reduce<br>def fn(x, y):<br>     return x * 10 + y<br>def char2num(s):<br>…     digits = {‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9}<br>…     return digits[s]<br>reduce(fn,[1,3,5,7,9])<br>map(char2num, ‘13579’)<br>13579</p>
</blockquote>
</blockquote>
</blockquote>
<p>3、python的filter函数<br>Python内建的filter()函数用于过滤序列。<br>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：<br>def is_odd(n):<br>    return n % 2 == 1</p>
<p>list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</p>
<h1 id="结果-1-5-9-15"><a href="#结果-1-5-9-15" class="headerlink" title="结果: [1, 5, 9, 15]"></a>结果: [1, 5, 9, 15]</h1><p>把一个序列中的空字符串删掉，可以这么写：<br>def not_empty(s):<br>    return s and s.strip()<br>list(filter(not_empty, [‘A’, ‘’, ‘B’, None, ‘C’, ‘  ‘]))</p>
<h1 id="结果-‘A’-‘B’-‘C’"><a href="#结果-‘A’-‘B’-‘C’" class="headerlink" title="结果: [‘A’, ‘B’, ‘C’]"></a>结果: [‘A’, ‘B’, ‘C’]</h1><p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。<br>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。<br>4、python的sort函数<br>Python内置的sorted()函数就可以对list进行排序：</p>
<blockquote>
<blockquote>
<blockquote>
<p>sorted([36, 5, -12, 9, -21])<br>[-21, -12, 5, 9, 36]<br>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：<br>sorted([36, 5, -12, 9, -21], key=abs)<br>Key函数放在前面行不行？<br>[5, 9, -12, -21, 36]<br>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。<br>再看一个字符串排序的例子：<br>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’])<br>[‘Credit’, ‘Zoo’, ‘about’, ‘bob’]<br>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。<br>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。<br>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：<br>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower)<br>[‘about’, ‘bob’, ‘Credit’, ‘Zoo’]<br>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True)<br>[‘Zoo’, ‘Credit’, ‘bob’, ‘about’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>5、匿名函数<br>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</p>
<p>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</p>
<blockquote>
<blockquote>
<blockquote>
<p>list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))<br>[1, 4, 9, 16, 25, 36, 49, 64, 81]<br>通过对比可以看出，匿名函数lambda x: x * x实际上就是：<br>def f(x):<br>    return x * x<br>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>（连续使用参数值会不会出现覆盖的情况？）<br>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。<br>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：<br>（为什么匿名函数需要通过变量来调用？）<br>f = lambda x: x * x<br>f<br>&lt;function <lambda> at 0x101c6ef28&gt;<br>f(5)<br>25<br>同样，也可以把匿名函数作为返回值返回，比如：</p>
</blockquote>
</blockquote>
</blockquote>
<p>def build(x, y):<br>return lambda: x * x + y * y<br>6、装饰器<br>函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</p>
<blockquote>
<blockquote>
<blockquote>
<p>def now():<br>…     print(‘2035-3-25’)<br>…<br>f = now<br>f()<br>2035-3-25<br>函数对象有一个<strong>name</strong>属性，可以拿到函数的名字：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>now.<strong>name</strong><br>‘now’<br>f.<strong>name</strong><br>‘now’<br>现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下:</p>
</blockquote>
</blockquote>
</blockquote>
<p>def log(func):<br>    def wrapper(<em>args, *</em>kw):<br>        print(‘call %s():’ % func.<strong>name</strong>)<br>        return func(<em>args, *</em>kw)<br>    return wrapper<br>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：<br>@log<br>def now():<br>    print(‘2015-3-25’)<br>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：<br>装饰器如果放在函数后面可不可以？</p>
<blockquote>
<blockquote>
<blockquote>
<p>now()<br>call now():<br>2015-3-25<br>把@log放到now()函数的定义处，相当于执行了语句：</p>
</blockquote>
</blockquote>
</blockquote>
<p>now = log(now)<br>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p>
<p>那为什么还会调用原来的函数呢？<br>wrapper()函数的参数定义是(<em>args, *</em>kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<p>def log(text):<br>    def decorator(func):<br>        def wrapper(<em>args, *</em>kw):<br>            print(‘%s %s():’ % (text, func.<strong>name</strong>))<br>            return func(<em>args, *</em>kw)<br>        return wrapper<br>    return decorator<br>这个3层嵌套的decorator用法如下：</p>
<p>@log(‘execute’)<br>def now():<br>    print(‘2015-3-25’)<br>执行结果如下：</p>
<blockquote>
<blockquote>
<blockquote>
<p>now()<br>execute now():<br>2015-3-25<br>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>now = log(‘execute’)(now)<br>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>
</blockquote>
</blockquote>
</blockquote>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有name等属性，但你去看经过decorator装饰之后的函数，它们的name已经从原来的’now’变成了’wrapper’：</p>
<blockquote>
<blockquote>
<blockquote>
<p>now.<strong>name</strong><br>‘wrapper’<br>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。<br>不需要编写wrapper.<strong>name</strong> = func.<strong>name</strong>这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：</p>
</blockquote>
</blockquote>
</blockquote>
<p>import functools</p>
<p>def log(func):<br>    @functools.wraps(func)<br>    def wrapper(<em>args, *</em>kw):<br>        print(‘call %s():’ % func.<strong>name</strong>)<br>        return func(<em>args, *</em>kw)<br>    return wrapper<br>或者针对带参数的decorator：</p>
<p>import functools</p>
<p>def log(text):<br>    def decorator(func):<br>        @functools.wraps(func)<br>        def wrapper(<em>args, *</em>kw):<br>            print(‘%s %s():’ % (text, func.<strong>name</strong>))<br>            return func(<em>args, *</em>kw)<br>        return wrapper<br>    return decorator</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模拟登录的几种方法</title>
    <url>/Python%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="方法一：直接使用已知的cookie访问"><a href="#方法一：直接使用已知的cookie访问" class="headerlink" title="方法一：直接使用已知的cookie访问"></a>方法一：直接使用已知的cookie访问</h1><p>特点：<br>　　简单，但需要先在浏览器登录<br>原理：<br>　　简单地说，cookie保存在发起请求的客户端中，服务器利用cookie来区分不同的客户端。因为http是一种无状态的连接，当服务器一下子收到好几个请求时，是无法判断出哪些请求是同一个客户端发起的。而“访问登录后才能看到的页面”这一行为，恰恰需要客户端向服务器证明：“我是刚才登录过的那个客户端”。于是就需要cookie来标识客户端的身份，以存储它的信息（如登录状态）。<br>　　当然，这也意味着，只要得到了别的客户端的cookie，我们就可以假冒成它来和服务器对话。这给我们的程序带来了可乘之机。<br>　　我们先用浏览器登录，然后使用开发者工具查看cookie。接着在程序中携带该cookie向网站发送请求，就能让你的程序假扮成刚才登录的那个浏览器，得到只有登录后才能看到的页面。<br>具体步骤：</p>
<h3 id="1-用浏览器登录，获取浏览器里的cookie字符串"><a href="#1-用浏览器登录，获取浏览器里的cookie字符串" class="headerlink" title="1.用浏览器登录，获取浏览器里的cookie字符串"></a>1.用浏览器登录，获取浏览器里的cookie字符串</h3><p>　　先使用浏览器登录。再打开开发者工具，转到network选项卡。在左边的Name一栏找到当前的网址，选择右边的Headers选项卡，查看Request Headers，这里包含了该网站颁发给浏览器的cookie。对，就是后面的字符串。把它复制下来，一会儿代码里要用到。<br>　　注意，最好是在运行你的程序前再登录。如果太早登录，或是把浏览器关了，很可能复制的那个cookie就过期无效了。<br><img src="/images/2020/07/13/a1fd95b7-1874-46a2-a2e0-11d63f13a18f.png" alt="image.png"></p>
<h3 id="2-写代码"><a href="#2-写代码" class="headerlink" title="2.写代码"></a>2.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　urllib库的版本：</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网站</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">req &#x3D; request.Request(url)</span><br><span class="line">#设置cookie</span><br><span class="line">req.add_header(&#39;cookie&#39;, raw_cookies)</span><br><span class="line">#设置请求头</span><br><span class="line">req.add_header(&#39;User-Agent&#39;, &#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;)</span><br><span class="line"></span><br><span class="line">resp &#x3D; request.urlopen(req)</span><br><span class="line"></span><br><span class="line">print(resp.read().decode(&#39;utf-8&#39;))</span><br><span class="line"> </span><br><span class="line">　　requests库的版本：</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#把cookie字符串处理成字典，以便接下来使用</span><br><span class="line">cookies &#x3D; &#123;&#125;</span><br><span class="line">for line in cookie_str.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; line.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    cookies[key] &#x3D; value</span><br></pre></td></tr></table></figure>
<h1 id="方法二：模拟登录后再携带得到的cookie访问"><a href="#方法二：模拟登录后再携带得到的cookie访问" class="headerlink" title="方法二：模拟登录后再携带得到的cookie访问"></a>方法二：模拟登录后再携带得到的cookie访问</h1><p>原理：<br>　　我们先在程序中向网站发出登录请求，也就是提交包含登录信息的表单（用户名、密码等）。从响应中得到cookie，今后在访问其他页面时也带上这个cookie，就能得到只有登录后才能看到的页面。<br>具体步骤：</p>
<h3 id="1-找出表单提交到的页面"><a href="#1-找出表单提交到的页面" class="headerlink" title="1.找出表单提交到的页面"></a>1.找出表单提交到的页面</h3><p>　　还是要利用浏览器的开发者工具。转到network选项卡，并勾选Preserve Log（重要！）。在浏览器里登录网站。然后在左边的Name一栏找到表单提交到的页面。怎么找呢？看看右侧，转到Headers选项卡。首先，在General那段，Request Method应当是POST。其次最下方应该要有一段叫做Form Data的，里面可以看到你刚才输入的用户名和密码等。也可以看看左边的Name，如果含有login这个词，有可能就是提交表单的页面（不一定！）。<br><img src="/images/2020/07/13/cf92bfd8-aa92-47de-b2ab-ef31b8988b03.png" alt="image.png"><br>这里要强调一点，“表单提交到的页面”通常并不是你填写用户名和密码的页面！所以要利用工具来找到它。</p>
<h3 id="2-找出要提交的数据"><a href="#2-找出要提交的数据" class="headerlink" title="2.找出要提交的数据"></a>2.找出要提交的数据</h3><p>　　虽然你在浏览器里登陆时只填了用户名和密码，但表单里包含的数据可不只这些。从Form Data里就可以看到需要提交的所有数据。<br><img src="/images/2020/07/13/f1a90959-0ed1-4d22-874a-8285b940c92c.png" alt="image.png"></p>
<h3 id="3-写代码"><a href="#3-写代码" class="headerlink" title="3.写代码"></a>3.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 　　urllib库的版本：</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">import urllib.request</span><br><span class="line">import http.cookiejar</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录时需要POST的数据</span><br><span class="line">data &#x3D; &#123;&#39;Login.Token1&#39;:&#39;学号&#39;, </span><br><span class="line">        &#39;Login.Token2&#39;:&#39;密码&#39;, </span><br><span class="line">        &#39;goto:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginSuccess.portal&#39;, </span><br><span class="line">        &#39;gotoOnFail:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginFailure.portal&#39;&#125;</span><br><span class="line">post_data &#x3D; urllib.parse.urlencode(data).encode(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#登录时表单提交到的地址（用开发者工具可以看到）</span><br><span class="line">login_url &#x3D; &#39; http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;userPasswordValidate.portal</span><br><span class="line"></span><br><span class="line">#构造登录请求</span><br><span class="line">req &#x3D; urllib.request.Request(login_url, headers &#x3D; headers, data &#x3D; post_data)</span><br><span class="line"></span><br><span class="line">#构造cookie</span><br><span class="line">cookie &#x3D; http.cookiejar.CookieJar()</span><br><span class="line"></span><br><span class="line">#由cookie构造opener</span><br><span class="line">opener &#x3D; urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie))</span><br><span class="line"></span><br><span class="line">#发送登录请求，此后这个opener就携带了cookie，以证明自己登录过</span><br><span class="line">resp &#x3D; opener.open(req)</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#构造访问请求</span><br><span class="line">req &#x3D; urllib.request.Request(url, headers &#x3D; headers)</span><br><span class="line"></span><br><span class="line">resp &#x3D; opener.open(req)</span><br><span class="line"></span><br><span class="line">print(resp.read().decode(&#39;utf-8&#39;))</span><br><span class="line"> </span><br><span class="line">　　requests库的版本：</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#浏览器登录后得到的cookie，也就是刚才复制的字符串</span><br><span class="line">cookie_str &#x3D; r&#39;JSESSIONID&#x3D;xxxxxxxxxxxxxxxxxxxxxx; iPlanetDirectoryPro&#x3D;xxxxxxxxxxxxxxxxxx&#39;</span><br><span class="line"></span><br><span class="line">#把cookie字符串处理成字典，以便接下来使用</span><br><span class="line">cookies &#x3D; &#123;&#125;</span><br><span class="line">for line in cookie_str.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; line.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    cookies[key] &#x3D; value</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#在发送get请求时带上请求头和cookies</span><br><span class="line">resp &#x3D; requests.get(url, headers &#x3D; headers, cookies &#x3D; cookies)</span><br><span class="line">        </span><br><span class="line">print(resp.content.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<h1 id="方法三：模拟登录后用session保持登录状态"><a href="#方法三：模拟登录后用session保持登录状态" class="headerlink" title="方法三：模拟登录后用session保持登录状态"></a>方法三：模拟登录后用session保持登录状态</h1><p>原理：<br>　　session是会话的意思。和cookie的相似之处在于，它也可以让服务器“认得”客户端。简单理解就是，把每一个客户端和服务器的互动当作一个“会话”。既然在同一个“会话”里，服务器自然就能知道这个客户端是否登录过。<br>具体步骤：</p>
<h3 id="1-找出表单提交到的页面-1"><a href="#1-找出表单提交到的页面-1" class="headerlink" title="1.找出表单提交到的页面"></a>1.找出表单提交到的页面</h3><p>2.找出要提交的数据<br>　　这两步和方法二的前两步是一样的</p>
<h3 id="3-写代码-1"><a href="#3-写代码-1" class="headerlink" title="3.写代码"></a>3.写代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requests库的版本</span><br><span class="line"> </span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer,encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#登录时需要POST的数据</span><br><span class="line">data &#x3D; &#123;&#39;Login.Token1&#39;:&#39;学号&#39;, </span><br><span class="line">        &#39;Login.Token2&#39;:&#39;密码&#39;, </span><br><span class="line">        &#39;goto:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginSuccess.portal&#39;, </span><br><span class="line">        &#39;gotoOnFail:http&#39;:&#39;&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;loginFailure.portal&#39;&#125;</span><br><span class="line"></span><br><span class="line">#设置请求头</span><br><span class="line">headers &#x3D; &#123;&#39;User-agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;60.0.3112.113 Safari&#x2F;537.36&#39;&#125;</span><br><span class="line"></span><br><span class="line">#登录时表单提交到的地址（用开发者工具可以看到）</span><br><span class="line">login_url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;userPasswordValidate.portal&#39;</span><br><span class="line"></span><br><span class="line">#构造Session</span><br><span class="line">session &#x3D; requests.Session()</span><br><span class="line"></span><br><span class="line">#在session中发送登录请求，此后这个session里就存储了cookie</span><br><span class="line">#可以用print(session.cookies.get_dict())查看</span><br><span class="line">resp &#x3D; session.post(login_url, data)</span><br><span class="line"></span><br><span class="line">#登录后才能访问的网页</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line">#发送访问请求</span><br><span class="line">resp &#x3D; session.get(url)</span><br><span class="line"></span><br><span class="line">print(resp.content.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>
<h1 id="方法四：使用无头浏览器访问"><a href="#方法四：使用无头浏览器访问" class="headerlink" title="方法四：使用无头浏览器访问"></a>方法四：使用无头浏览器访问</h1><p>特点：<br>　　功能强大，几乎可以对付任何网页，但会导致代码效率低<br>原理：<br>　　如果能在程序里调用一个浏览器来访问网站，那么像登录这样的操作就轻而易举了。在Python中可以使用Selenium库来调用浏览器，写在代码里的操作（打开网页、点击……）会变成浏览器忠实地执行。这个被控制的浏览器可以是Firefox，Chrome等，但最常用的还是PhantomJS这个无头（没有界面）浏览器。也就是说，只要把填写用户名密码、点击“登录”按钮、打开另一个网页等操作写到程序中，PhamtomJS就能确确实实地让你登录上去，并把响应返回给你。<br>具体步骤：</p>
<h3 id="1-安装selenium库、PhantomJS浏览器"><a href="#1-安装selenium库、PhantomJS浏览器" class="headerlink" title="1.安装selenium库、PhantomJS浏览器"></a>1.安装selenium库、PhantomJS浏览器</h3><p>2.在源代码中找到登录时的输入文本框、按钮这些元素<br>　　因为要在无头浏览器中进行操作，所以就要先找到输入框，才能输入信息。找到登录按钮，才能点击它。<br>　　在浏览器中打开填写用户名密码的页面，将光标移动到输入用户名的文本框，右键，选择“审查元素”，就可以在右边的网页源代码中看到文本框是哪个元素。同理，可以在源代码中找到输入密码的文本框、登录按钮。</p>
<h3 id="3-考虑如何在程序中找到上述元素"><a href="#3-考虑如何在程序中找到上述元素" class="headerlink" title="3.考虑如何在程序中找到上述元素"></a>3.考虑如何在程序中找到上述元素</h3><p>　　Selenium库提供了find_element(s)_by_xxx的方法来找到网页中的输入框、按钮等元素。其中xxx可以是id、name、tag_name（标签名）、class_name（class），也可以是xpath（xpath表达式）等等。当然还是要具体分析网页源代码。</p>
<h3 id="4-写代码"><a href="#4-写代码" class="headerlink" title="4.写代码"></a>4.写代码</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import io</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">sys.stdout &#x3D; io.TextIOWrapper(sys.stdout.buffer, encoding&#x3D;&#39;utf8&#39;) #改变标准输出的默认编码</span><br><span class="line"></span><br><span class="line">#建立Phantomjs浏览器对象，括号里是phantomjs.exe在你的电脑上的路径</span><br><span class="line">browser &#x3D; webdriver.PhantomJS(&#39;d:&#x2F;tool&#x2F;07-net&#x2F;phantomjs-windows&#x2F;phantomjs-2.1.1-windows&#x2F;bin&#x2F;phantomjs.exe&#39;)</span><br><span class="line"></span><br><span class="line">#登录页面</span><br><span class="line">url &#x3D; r&#39;http:&#x2F;&#x2F;ssfw.xmu.edu.cn&#x2F;cmstar&#x2F;index.portal&#39;</span><br><span class="line"></span><br><span class="line"># 访问登录页面</span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"># 等待一定时间，让js脚本加载完毕</span><br><span class="line">browser.implicitly_wait(3)</span><br><span class="line"></span><br><span class="line">#输入用户名</span><br><span class="line">username &#x3D; browser.find_element_by_name(&#39;user&#39;)</span><br><span class="line">username.send_keys(&#39;学号&#39;)</span><br><span class="line"></span><br><span class="line">#输入密码</span><br><span class="line">password &#x3D; browser.find_element_by_name(&#39;pwd&#39;)</span><br><span class="line">password.send_keys(&#39;密码&#39;)</span><br><span class="line"></span><br><span class="line">#选择“学生”单选按钮</span><br><span class="line">student &#x3D; browser.find_element_by_xpath(&#39;&#x2F;&#x2F;input[@value&#x3D;&quot;student&quot;]&#39;)</span><br><span class="line">student.click()</span><br><span class="line"></span><br><span class="line">#点击“登录”按钮</span><br><span class="line">login_button &#x3D; browser.find_element_by_name(&#39;btn&#39;)</span><br><span class="line">login_button.submit()</span><br><span class="line"></span><br><span class="line">#网页截图</span><br><span class="line">browser.save_screenshot(&#39;picture1.png&#39;)</span><br><span class="line">#打印网页源代码</span><br><span class="line">print(browser.page_source.encode(&#39;utf-8&#39;).decode())</span><br><span class="line"></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python类</title>
    <url>/python%E7%B1%BB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>类的声明：<br>一、类的属性<br>（私有属性和公有属性）<br>（类属性）<br>二、类的方法<br>（构造方法、析构方法、自定义方法、特殊成员方法）<br>（静态方法、类方法、类属性）<br>三、类的继承<br>（方法和属性的继承，方法的重构）<br>（抽象类，多重继承）<br>四、类的多态<br>（实现接口的重用）<br>五、类的特殊装饰<br>（@staticmethod、@classmethod、@property）<br>六、类的来源和原类（metaclass）<br>七、反射<br>    类的声明<br>使用class声明类，建议类名单词首字母大写。<br>“新式类”和“经典类”的区分在Python 3之后就已经不存在，在Python 3.x之后的版本，因为所有的类都派生自内置类型object(即使没有显示的继承object类型)，即所有的类都是“新式类”。<br>新式类：<br>class Management(object):</p>
<pre><code>def add():
    pass
  经典类：</code></pre><p>class Management:<br>    pass</p>
<p>    类的属性<br>类的属性就是类定义的变量值。<br>       公有属性：在类里直接定义的属性，它在类名下面直接定义。<br>                        调用：1、类中调用：类名.属性名 ，更改原公有属性值<br>                                   2、实例调用：实例.属性名<br>class Management(object):<br>    num = 10<br>    def add(self):<br>        Management.num +=10            # 类中调用公有属性并更改值，num=11<br>        pass<br>s1 = Management()<br>s2 = Management()</p>
<h1 id="第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性"><a href="#第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性" class="headerlink" title="第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性"></a>第一种情况：s1实例中调用公有属性，s2实例没有调用公有属性</h1><p>s1.num +=1<br>Management.num += 2<br>“””&lt;结果&gt;<br>s1不变，s2和Management都改变了<br>s1_num:11   s2_num:12   Manage_num:12”””</p>
<h1 id="第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改"><a href="#第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改" class="headerlink" title="第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改"></a>第二种情况：先调用s1实例公有属性，再通过S1调用add更改，然后再使用类更改</h1><p>s1.num +=1<br>s1.add()<br>Management.num += 2<br>“””&lt;结果&gt;<br>先调用的s1实例num依然不变，s2和Management都被修改了<br>s1_num:11   s2_num:22   Manage_num:22”””<br> 问题：为什么修改num的值以后，实例s1和实例s2会有不同的结果呢 ？<br>            因为公有属性查找的顺序是：先找实例的公有属性，没找到再找类里的公有属性<br>            可以这样理解：Management相当于一个微信群，num是群里发的一张照片，S1和S2是群里面的两个人。<br>            情况1：S1把照片存到本地，P了个双眼皮，S2说太难看了，我也不会P图，不保存。这个时候发照片的Management说我也觉得难看，把图撤回，重新发了一个P的图。S2就只能保存最新的图片。<br>            情况2：S1找到Management说你的图太丑了，重新改一下吧，Management说好！撤回图片修改了~</p>
<pre><code>私有属性：加两个下划线，__membername,编译的时候自动加上类名，变成_classname__membername，这种技术叫变量名压缩(mangling)，以达到外部不能调用的目的。实际使用_classname__membername是可以调用的，但是不符合规定。标准方法是通过定义函数来获取。</code></pre><p>class Classname(object):<br> ‘’’this is a demo!’’’<br> def <strong>init</strong>(self):<br>  self.__membername = 88</p>
<p> def read_membername(self):            # 标准的外部访问方法,使用函数来读取私有属性。<br>  return self.__membername</p>
<p>s= Classname()<br>print(s.<em>Classname__membername)<br>print(s.read_membername())<br>‘’’<br>&lt;结果&gt;<br>88<br>88<br>——像下面的调用，会出现AttributeError错误——<br>print(s.<em>_membername)<br>‘’’<br>       类属性：  类自带的属性,需要注意的是实例化的类属性，和原类的类属性不同。用上面的例子作演示。<br>属性    作用    示例    结果<br>__doc</em></em>    类的文档字符串    print(s.<strong>doc</strong>)<br>print(Classname.<strong>doc</strong>)    this is a demo!<br>this is a demo!<br><strong>dict</strong>    类的属性组成的字典    print(s.<strong>dict</strong>)<br>print(Classname.<strong>dict</strong>)    {‘<em>Classname__membername’: 88}<br>{‘<em>_init</em></em>‘:, ‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘<strong>doc</strong>‘: ‘\nthis is a demo!\n’, ‘read_membername’:}<br><strong>name</strong>    类的名字（字符串）    ##不能用于实例print(s.<strong>name</strong> )<br>print(Classname.<strong>name</strong> )<br>Classname<br><strong>bases</strong>    类的所有父类组成的元组    #不能用于实例print(s.<strong>bases</strong>)<br>print(Classname.<strong>bases</strong>)<br>(,)为什么没有值？可能是编译器问题<br><strong>module</strong>    类所属的模块    print(s.<strong>module</strong>)<br>print(Classname.<strong>module</strong>)    <strong>main</strong><br><strong>main</strong><br><strong>class</strong>    类对象的类型    print(s.<strong>class</strong>)<br>print(Classname.<strong>class</strong>)    待测<br><strong>slots</strong>    限定类属性，在类属性位置定义<br>未在slots定义的属性都是非法属性    <strong>slots</strong>.(‘name’,’age’,’sexy’)    使用’name’,’age’,’sexy’的以外属性会报错</p>
<p>    类的方法<br>类的方法就是类里面定义的函数。类的构造方法、析构方法、自定义类方法、静态方法、类方法、属性方法、特殊成员方法。<br>构造方法：<strong>init</strong><br>实例化类的时候就会运行的函数。希望初始化的参数放置在init下面。(个人觉得，这个初始化参数可以是一切对象！)<br>class A(object):<br> def instense(self):<br>  print(“init obj A”)</p>
<p>class B(object):<br> def <strong>init</strong>(self, para):<br>  self.init_para = para<br>  self.obj_A = A()<br>  self.num = 1</p>
<p> def show(self):<br>  print(self.init_para)<br>  self.obj_A.instense()<br>  print(self.num)<br>haha = B(“this is para”)<br>haha.show()</p>
<hr>
<p>this is para</p>
<p>init obj A</p>
<p>1<br>   析构方法：<br>   <strong>del</strong>：销毁实例时，方法才会执行。<br>class Hello(object):<br>    def <strong>del</strong>(self):<br>        print(“你删除了实例”)</p>
<h1 id="在python上测试"><a href="#在python上测试" class="headerlink" title="在python上测试"></a>在python上测试</h1><p>instance = Hello()<br>del instance</p>
<h1 id="当然也可以使用实例调用，但没有这么用的"><a href="#当然也可以使用实例调用，但没有这么用的" class="headerlink" title="当然也可以使用实例调用，但没有这么用的~~"></a>当然也可以使用实例调用，但没有这么用的~~</h1><p>instance.<strong>del</strong>()</p>
<p>  自定义方法：<br>  除去类中自带的以<em>下划线开头的函数，在类中定义一个函数，实现相应的功能。<br>class Person(object):<br>    def <em>_init</em></em>(self,person_name, person_age)<br>   静态方法：<br>    @staticmethod，不需要访问类里的任何参数。所带的参数都是从外部传入的。<br>class Person(object):<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@staticmethod
def info(country):
    print(country)</code></pre><p>   类方法：<br>   @classmethod,第一个参数必须是类属性。<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@classmethod
def info(country):
    print(country)</code></pre><p>属性方法：<br>1ban<br>    @property把一个函数变成一个静态属性<br>    直接调用函数名字，不需要加括号，就能获取到函数返回值。一般用在不注重过程，只要结果的情况!<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@property
def health_point(self):
    print(&quot;HP:【{}】&quot;.format(self.age*2))
    return self.age*2</code></pre><p>P = Person(“laowang”,23)<br>P.health_point                # 不需要括号，看起来完全是一个属性，这就是属性方法</p>
<p>‘’’上面的类属性只是只读的，即然是叫属性，那么只读就显得太LOW了’’’<br>    类属性装饰器@property,装饰以后，函数就有：赋值setter\销毁deleter两个方法。<br>class Person(object):<br>    country = “china”<br>    def <strong>init</strong>(self,person_name, person_age):<br>        self.name = person_name<br>        self.age = person_age</p>
<pre><code>@property
def health_point(self):
    self.age = self.age*2
    print(&quot;HP:【{}】&quot;.format(self.age))
    return self.age

@health_point.setter                    # 增加了一个赋值方法
def health_point(self, add):
    self.age = add

@health_point.deleter                   # 增加了一个销毁属性的方法
def health_point(self):
    del self.age</code></pre><p>P = Person(“laowang”, 33)<br>print(P.health_point)</p>
<p>P.health_point = 22                        # 给health.point赋值<br>print(P.health_point)</p>
<p>del P.health_point                         # 销毁属性</p>
<pre><code>特殊成员方法：</code></pre><p>方法    作用    示例    结果<br><strong>call</strong>    默认未定义<br>类实例化后,调用实例运行的方法    p = Person()<br>p()    Person是类名<br>实例p没有调用函数，加()运行call方法<br><strong>str</strong>    默认未定义,定义时必须有返回值<br>定义时，打印实例，输入str返回值    p = Person()<br>print (p)    Person是类名<br>打印实例p，运行str方法，打印返回值<br><strong>getitem</strong>    用于索引操作，如字典。获取数据    p = Person()<br>p[‘name’]    自动运行getitem<br><strong>setitem</strong>    用于索引操作，如字典。赋值    p = Person()<br>p[‘name’] = ‘David’    自动运行setitem<br><strong>delitem</strong>    用于索引操作，如字典。删除数据    p = Person()<br>del p[‘name’]    自动运行delitem<br><strong>new</strong>    类实例化时，执行<strong>new</strong>，并且会阻止<br>init运行，可以在new里调用init<br>    p = Person()    参照例子二<br><strong>len</strong>    待续<br><strong>cmp</strong>    待续<br>‘’’例子一call\str\getitem\setitem\delitem方法’’’<br>class Person(object):<br> def <strong>call</strong>(self):<br>  print(“print call”)</p>
<p> def <strong>str</strong>(self):<br>  print(“print str:”,end=’’)<br>  return “1”</p>
<p> def <strong>getitem</strong>(self,key):<br>  print(“getitem:”,key)</p>
<p> def <strong>setitem</strong>(self,key,value):<br>  print(‘setitem:’,key,value)</p>
<p> def <strong>delitem</strong>(self,key):<br>  print(‘delitem:’,key)</p>
<p>p = Person()<br>p()<br>print(p)<br>print(‘———–’)<br>get = p[‘name’]<br>p[‘name’] = ‘David’<br>del p[‘name’]<br>‘’’例子二：<strong>new</strong>/<strong>init</strong>‘’’<br>class Person(object):</p>
<p> def <strong>init</strong>(self):</p>
<p>  print(‘this is init!’)</p>
<p> def <strong>new</strong>(self):                  # <strong>new</strong>会阻断<strong>init</strong>执行，要想执行，需要写init方法</p>
<p>  print(“this is new!”)</p>
<p>  self.<strong>init</strong>(self)        # 如果去掉这一行，init不能执行</p>
<p>p = Person()<br>    类的来源和元类：<br>    <a href="http://blog.jobbole.com/21351/中文版详细解答。下面写一个自己理解的简版的。" target="_blank" rel="noopener">http://blog.jobbole.com/21351/中文版详细解答。下面写一个自己理解的简版的。</a><br>    首先，类也是对象，可以：<br>    1)   你可以将它赋值给一个变量<br>    2)   你可以拷贝它<br>    3)   你可以为它增加属性<br>    4)   你可以将它作为函数参数进行传递</p>
<pre><code>类也是是由type()这个函数创建的，type是类的类，类的爹。学名叫元类！
也许有人会问那为啥type()能查看到数据类型呢？
可能你会注意到，type的结果前是class。。。因为数据类型在Python中都是类定义的，这也说明了，为什么数字，字符等等全是对象。

type格式：
type(类名,(父类元组),{属性和方法的字典})  ,  父类元组可以没有；后面两个典省略时，默认值为None。</code></pre><p>‘’’一言不合就上例子’’’</p>
<p>Person = type(‘Person’,(),{‘country’:’china’})</p>
<p>print(Person.country)</p>
<h1 id="带继承Person类的用法"><a href="#带继承Person类的用法" class="headerlink" title="带继承Person类的用法"></a>带继承Person类的用法</h1><p>def run():                    # 定义函数，把run传给Action的leg方法。<br>    print(‘running…’)</p>
<p>Action = type(‘Action’,(Person,),{‘leg’:run})</p>
<p>print(Action.country)<br>Action.leg()</p>
<pre><code>metaclass:
创建类的时候，使用metaclass，python就会使用指定的元类创建类。找不到则使用type创建。</code></pre><p>class MyType(type):<br>    def <strong>init</strong>(self,<em>args,*</em>kwargs):</p>
<pre><code>    print(&quot;Mytype __init__&quot;,*args,**kwargs)

def __call__(self, *args, **kwargs):
    print(&quot;Mytype __call__&quot;, *args, **kwargs)
    obj = self.__new__(self)
    print(&quot;obj &quot;,obj,*args, **kwargs)
    print(self)
    self.__init__(obj,*args, **kwargs)
    return obj

def __new__(cls, *args, **kwargs):
    print(&quot;Mytype __new__&quot;,*args,**kwargs)
    return type.__new__(cls, *args, **kwargs)</code></pre><p>print(‘here…’)<br>class Foo(object,metaclass=MyType):<br>    def <strong>init</strong>(self,name):<br>        self.name = name</p>
<pre><code>    print(&quot;Foo __init__&quot;)

def __new__(cls, *args, **kwargs):
    print(&quot;Foo __new__&quot;,cls, *args, **kwargs)
    return object.__new__(cls)</code></pre><p>f = Foo(“Alex”)<br>print(“f”,f)<br>print(“fname”,f.name)</p>
<p>    类的继承<br>代码重用。<br>    Python3中类有单继承和多继承，其中多继承与Python2的继承顺序不同。<br>    子类方法与父类重名，子类方法会覆盖父类<br>  单继承：<br>‘’’一言不合就上例子’’’</p>
<p>class Person(object):<br>    def <strong>init</strong>(self,person_name):<br>        self.name = person_name<br>    def info(self):<br>        print(“this is personal info:\nname:{}”.format(self.name))</p>
<p>class Action(Person):<br>    def <strong>init</strong>(self,person_name):<br>    ‘’’父类析构函数有两种继承方法’’’<br>        super(Action, self).<strong>init</strong>(person_name)     # 方法一<br>        # Person.<strong>init</strong>(self, person_name)          # 方法二<br>    # —-<br>    # 如果自已带参数写在继承的参数前面,然后在super里再声明一下父类变量<br>    # def <strong>init</strong>(self,person_sex,person_name):<br>    #     super(Action,self).<strong>init</strong>(person_name)<br>    # —-</p>
<pre><code>def run(self):
    print(&quot;{} is running...&quot;.format(self.name))</code></pre><p>a = Action(‘Alex’)<br>a.run()                            # 继承了Person的属性。<br>a.info()                           # 继承了Person的方法。</p>
<p>多重继承：<br>不能同时继承两父亲类和爷爷类比如B继承A，C继承时就不能同时写A和B，只写B就可以了。</p>
<p>class ROOT(object):<br>    def <strong>init</strong>(self):<br>        print(“this is root”)<br>    def action(self):<br>        print(“ROOT is action…”)</p>
<p>class A(ROOT):<br>    def <strong>init</strong>(self):<br>        super(A, self).<strong>init</strong>()<br>        print (‘init A…’)<br>    def action(self):<br>        print(“A is action…”)</p>
<p>class B(ROOT):<br>    def <strong>init</strong>(self):<br>        super(B, self).<strong>init</strong>()<br>        print (‘init B…’)<br>    def action(self):<br>        print(“B is action…”)</p>
<p>class C(A):<br>    def <strong>init</strong>(self):<br>        super(C, self).<strong>init</strong>()<br>        print (‘init C…’)<br>    def action(self):<br>        print(“C is action…”)</p>
<p>class D(B,C):<br>    def <strong>init</strong>(self):<br>        super(D, self).<strong>init</strong>()<br>        print (‘init D…’)<br>    def action(self):<br>        print(“D is action…”)</p>
<p>d = D()</p>
<p>要理解继承的顺序，因为当方法重名时，顺序靠后的方法覆盖前面的方法。<br>类的继承关系：                D(A,B)实例化时候的继承先后顺序：先找B（及其父类），再找C（及其父类）</p>
<h1 id="多重继承的参数"><a href="#多重继承的参数" class="headerlink" title="多重继承的参数"></a>多重继承的参数</h1><p>class A(object):<br>    def <strong>init</strong>(self,sever_ip):<br>        self.ip = sever_ip</p>
<pre><code>def show(self):
    print(&apos;IP:&apos;,self.ip)</code></pre><p>class B(object):<br>    def <strong>init</strong>(self,server_port):<br>        self.port = server_port</p>
<pre><code>def show(self):
    print(&apos;PORT:&apos;,self.port)</code></pre><p>class C(A,B):<br>    def <strong>init</strong>(self,server_port,server_ip):        # 先写B的参数，再写A的参数。<br>        super(C,self).<strong>init</strong>(server_port)          # B的参数继承<br>        super(A,self).<strong>init</strong>(server_ip)            # C的参数继承</p>
<pre><code>def show_b(self):
    print(self.ip,self.port)</code></pre><p>c = C(‘192.168.1.1’,1234)<br>c.show_b()<br>c.show()        # 先继承B的show，再继承A的show，A把B的show 替换掉了，所以此处运行的是A的show方法</p>
<p>    类的多态<br>    多态就是同一个父类的方法，不同子类继承可以进行不同的改写，实现多种不同的功能。<br>    任何依赖父类作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。<br>‘’’接着上面的例子’’’</p>
<h1 id="定义一个函数，把ROOT类传进里面"><a href="#定义一个函数，把ROOT类传进里面" class="headerlink" title="定义一个函数，把ROOT类传进里面"></a>定义一个函数，把ROOT类传进里面</h1><p>def who_action(class_name):<br>    class_name.action()</p>
<p>who_action(ROOT())<br>who_action(D())<br>who_action(A())</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python练习</title>
    <url>/python%E7%BB%83%E4%B9%A0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1、 执行 Python 脚本的两种方式<br>1）/usr/bin/python3  xx.py<br>2）python3 xx.py  #注xx.py需要在内容里面调用由什么解释器执行<br>2、 简述位、字节的关系<br>1Byte = 8bit<br>1bit 表示某个二进制 0 1<br>3、 简述 ascii、unicode、utf-8、gbk 的关系<br>最初计算机是由美国发明的，计算机需要一套相应的字符编码集ascii，来表示英文字符<br>后来中国也表示也用来计算机，也需要一套字符编码集来表示汉字字符，也就是gbk<br>由于各国需要用计算机都需要一套相应的字符编码，来表示自已国家的字符，<br>于是就出现统一的字符编码的集也就是unicode，所有的字符都表示两个字节，<br>原来英文字符只占用一个字节，存放英文字符文档，会浪费一倍的空间，美国肯定不会同意<br>于是就出现了utf-8编码，可变长的字符编码，英文字符编码表示1个字节，汉字表示3个字节<br>这下美国就开兴了哈！<br>4、 请写出 “你好” 分别用 utf-8 和 gbk 编码所占的位数<br>你好  在utf-8中一个中文字符3个字节(Byte)  1字节 = 8位(bit) 你好就在utf-8表示24位<br>你好  在gbk中一个中文字符用2个字节(Byte)  1字节 = 8位(bit) 你好就在gbk中表示16位<br>5、 Pyhton 单行注释和多行注释分别用什么？<br>单行注释:用 #注释内容<br>多行注释:用’’’注释内容’’’    或者   “””注释内容”””<br>6、 声明变量注意事项有那些？<br>1 变量名不能以数字开头<br>2 变量名只能是数字，下划线，英文字母的组合<br>3 变量名不能有特殊符号<br>4 某些特定的字符不能用做变量名<br>7、 如何查看变量在内存中的地址?<br>id(变量名)<br>8、 执行 Python 程序时，自动生成的  .pyc文件的作用是什么？<br>当执行xx.py的python会 把编译的结果会保存在位于内存中的Pycodeobject中，<br>python程序运行结束，python解释器则将PyCodeObject写回到pyc文件中。<br>当python再次执行xx.py时，首先程序会在硬盘中寻找pyc文件，直接载入，否则就重复上面的<br>过程<br>.pyc文件在<em>pycache</em></p>
<p>注：自已理解，我也不是很了解<br>9、写代码<br>a.实现用户输入用户名和密码，当用户名为seven且密码为123时，<br>显示登陆成功，否则登陆失败！<br>代码如下：</p>
<p>user  =  “seven”<br>passwd = 123<br>username = input(“please the enter user:”)<br>password = int(input(“please the enter passwd:”))<br>if username == user and password == passwd:<br>    print(“logon successfull”)<br>else:<br>    print(“logon failed”)<br>注意:input()输入的任何内容都是字符串（存储str）<br>b.实现用户输入用户名和密码，当用户名为 seven且密码为 123 时，<br>显示登陆成功，否则登陆失败，失败时允许重复输入三次<br>代码如下</p>
<p>user  =  “seven”<br>passwd =  “123456”<br>（string）<br>print passwd.isdigit();<br>print user.isdigit();</p>
<p>for i in range(3):<br>    username = input(“please the enter user:”)<br>    password = input(“please the enter passwd:”)<br>    if password.isdigit():<br>        password = int(password)<br>        if username == user and passwd == password:<br>            print(“logon successfull”)<br>            break<br>        else:<br>            print(“logon failed”)<br>    else:<br>        print(“logon failed”)<br>c.实现用户输入用户名和密码，当用户名为 seven 或 alex 且密码为 123 时，<br>显示登陆成功，否则登陆失败，失败时允许重复输入三次<br>代码如下：</p>
<p>user  =  [“seven”,”alex”]<br>passwd =  123<br>for i in range(3):<br>    username = input(“please the enter user:”)<br>    password = input(“please the enter passwd:”)<br>    if password.isdigit():<br>        password = int(password)<br>        if (username in user)  and passwd == password:<br>            print(“logon successfull”)<br>            break<br>        else:<br>            print(“logon failed”)<br>    else:<br>        print(“logon failed”)<br>10、写代码<br>a.使用 while 循环实现输出 2-3+4¬-5+6 …+100 的和<br>代码如下：</p>
<p>even = 0<br>count = 1<br>while count&lt;100:<br>    count+=1<br>    #方法1：得出偶数-奇数+偶数-奇数…<br>    #方法2：求出所有的偶数减去所有的奇数和 （跟小学的换位运算类似）<br>    if count % 2 == 0:<br>        print(“2-100的偶数”,count)<br>        even += count<br>    else:<br>        print(“2-100的奇数”,count)<br>        even -= count<br>print(even) #得出的结果<br>b.使用 for 循环和 range 实现输出1-2+3-4+5-6….-98+99  的和<br>代码如下：</p>
<p>uneven = 0<br>for i in range(1,100):<br>    #方法1:得出的奇数-偶数+奇数-偶数….<br>    #方法2:求出奇数和，求出偶数和，用奇数和减偶数和<br>    if i % 2 == 1:<br>        print(“1-99的奇数”,i)<br>        uneven += i<br>    else:<br>        print(“1-99的偶数”,i)<br>        uneven -= i<br>print(uneven)   #得出结果<br>c.使用 while 循环实现输出1，2，3，4，5，7，8，9，11，12<br>代码如下：</p>
<p>count = 0<br>while count &lt;12:<br>    count += 1<br>    if count == 6:<br>        continue<br>    elif count ==10:<br>        continue<br>    print(count)<br>d.使用 while 循环实现输出 1-100 内的所有奇数<br>代码如下：</p>
<p>count = 0<br>while count &lt; 100:<br>    count += 1<br>    if count % 2 == 1:<br>        print(“1-100的奇数”,count)<br>e. 使用 while 循环实现输出1-100内的所有偶数<br>代码如下：</p>
<p>count = 0<br>while count &lt; 100:<br>    count += 1<br>    if count % 2 == 0:<br>        print(“1-100的偶数”,count)<br>11、分别书写数字5，10，32，7的二进制表示</p>
<p>在python解释器中执行bin(number)，把某个数字转换成二进制<br>二进制的表示:0b (binary)<br>bin(5)    #0b101<br>bin(10)  #0b1010<br>bin(32)  #0b100000<br>bin(7)    #0b111<br>12、简述对象和 类的关系（可用比喻的手法）<br>类：用来描述具有相同属性和方法的对象集合，<br>它定义每个对象的属性所共有的属性和方法，对象是类的实例<br>对象：通过类定义的数据结构实例</p>
<p>假如：人是一个种类，我们自已本身就是类的对象<br>类是一张图纸（该图纸上画了建筑的模型，以及怎样实现），实际高楼大夏就是图纸<br>实现的对象，<br>类是抽象的，对象是实际存在的。<br>13、现有如下两个变量，请简述 n1 和 n2是什么关系？<br>n1=123<br>n2=123<br>n1和n2关系是一样 ，我们可以用id(n1),id(n2)在内存中的地址的表示<br>14、现有如下两个变量，请简述 n1 和 n2是什么关系？<br>n1 = 123456<br>n2 = 123456<br>n1和n2虽然在值是一样的，在内存地址表示中是不一样的</p>
<p>注：<br>（在python内部中，内存还有一个(小数字池，字符串池)缓存池，对于经常用的，<br>在python内部编译有一个优化，在这个缓存池，如果重复使用，都是使用同一内存缓存池的内存（地址）空间<br>如果大于这个缓存池，则会在内存独立开辟新的一个内存（地址）空间<br>例如<br>数字的缓存池 -5 至 256<br>可以用不相同的变量名，相同的值，用id(变量名)，看它们的内存地址）</p>
<p>15、现有如下两个变量，请简述 n1 和 n2 是什么关系？<br>n1 = 123456<br>n2 = n1<br>n1 = 1234</p>
<p>n2 是 n1 值的引用   它们在内存的地址是一样和内容也是一样的，只是不同命名<br>变量的赋值:<br>赋值不会开辟新的内存空间，它只是复制了新对象的引用，如果n1的值发生改变，<br>n2还是原来的改变之前值<br>16、如有一下变量 n1 =5，请使用 int 的提供的方法，<br>得到该变量最少可以用多少个二进制位表示？<br>n1= 5<br>print(n1.bit_length())<br>#结果<br>3<br> 17、布尔值分别有什么？<br>True  False<br>18、阅读代码，请写出执行结果<br>a = “alex”<br>b = a.capitalize()<br>print(a)<br>print(b)<br>请写出输出结果：<br>alex    #a<br>Alex    #b<br>19、写代码，有如下变量，请按照要求实现每个功能<br>name = “ aleX”<br>a. 移除 name 变量对应的值两边的空格，并输入移除有的内容</p>
<p>print(name.strip())<br>#结果<br>aleX<br>b.判断 name 变量对应的值是否以 “al” 开头，并输出结果</p>
<p>print(name.startswith(“al”))<br>#结果<br>False<br>c.判断 name 变量对应的值是否以 “X” 结尾，并输出结果</p>
<p>print(name.endswith(“X”))<br>#结果<br>True<br>d.将 name 变量对应的值中的 “ l” 替换为 “ p”，并输出结果</p>
<p>print(name.replace(“l”,”p”))<br>#结果<br>    apeX<br>e.将 name 变量对应的值根据 “ l” 分割，并输出结果。</p>
<p>print(name.split(“l”))<br>#结果<br>[‘\ta’, ‘eX’]  #\t 表示使用了tab<br>f.请问，上一题 e分割之后得到值是什么类型？</p>
<p>print(type(name.split(“l”)))<br>#结果<br>&lt;class ‘list’&gt; #列表<br>g.将 name 变量对应的值变大写，并输出结果</p>
<p>print(name.upper())<br>    ALEX<br>h.将 name 变量对应的值变小写，并输出结果</p>
<p>print(name.lower())<br>#结果<br>    alex</p>
<p>i.请输出 name 变量对应的值的第 2 个字符？</p>
<p>print(name[2])<br>#结果<br>l<br>j. 请输出 name 变量对应的值的前 3 个字符？</p>
<p>print(name[:3])<br>#结果<br>    al<br>k. 请输出 name 变量对应的值的后 2 个字符？</p>
<p>print(name[-2:])<br>#结果<br>eX<br>l.请输出 name 变量对应的值中 “ e” 所在索引位置？</p>
<p>print(name.index(‘e’))<br>#结果<br>3<br> 20、字符串是否可迭代？如可以请使用 for 循环每一个元素？</p>
<p>字符串可以迭代<br>代码如下：<br>hobby = “一条龙”<br>for i in hobby:<br>    print(i)<br>显示结果如下：<br>一<br>条<br>龙<br>21、请用代码实现：利用下划线将列表的每一个元素拼接成字符串，<br>li = [‘alex’, ‘eric’, ‘rain’]</p>
<p>print(“_”.join(li))<br>#结果<br>alex_eric_rain<br>22、写代码，有如下列表，按照要求实现每一个功能<br>li = [‘alex’,’eric’,’rain’]<br>a.计算列表长度并输出</p>
<p>print(len(li))<br>#结果<br>3<br>b.列表中追加元素 “seven”，并输出添加后的列表</p>
<p>li.append(“seven”)<br>print(li)<br>#结果<br>[‘alex’, ‘eric’, ‘rain’, ‘seven’]<br>c.请在列表的第1个位置插入元素 “Tony”，并输出添加后的列表</p>
<p>li.insert(0,”Tony”)<br>print(li)<br>#结果<br>[‘Tony’, ‘alex’, ‘eric’, ‘rain’]<br>d.请修改列表第2个位置的元素为 “Kelly”，并输出修改后的列表</p>
<p>li[1] = “Kelly”<br>print(li)<br>#结果<br>[‘alex’, ‘Kelly’, ‘rain’]<br>e.请删除列表中的元素 “eric”，并输出修改后的列表</p>
<p>第一种：得出“eric”索引，通过索引来删除该值<br>第二种：直接删除”eric”<br>1)<br>del li[1];print(li)   #结果[‘alex’, ‘rain’]<br>li.pop(1);print(li)   #结果[‘alex’, ‘rain’]<br>2)<br>li.remove(“eric”)<br>print(li)<br>#结果<br>[‘alex’, ‘rain’]<br>f.请删除列表中的第2个元素，并输出删除的元素的值和删除元素后的列表</p>
<p>print(li.pop(1));print(li)<br>#结果<br>eric<br>[‘alex’, ‘rain’]<br>g.请删除列表中的第3个元素，并输出删除元素后的列表</p>
<p>print(li.pop(2));print(li)<br>#结果<br>rain<br>[‘alex’, ‘eric’]<br>h.请删除列表中的第2至4个元素并输出删除元素后的列表</p>
<p>del li[1:3]<br>print(li)<br>#结果<br>[‘alex’]<br>i.请将列表所有的元素反转，并输出反转后的列表</p>
<p>li.reverse()<br>print(li)<br>#结果<br>[‘rain’, ‘eric’, ‘alex’]<br>j.请使用 for、len、range 输出列表的索引</p>
<p>#3种方法，建议用第三种<br>1)for<br>for i in li:<br>    #list.index()列表有相同元素的,只是的获取（相同元素中的第一个元素）的索引<br>    print(li.index(i),i)  #如果列表内有相同的元素，不建议使用此方法<br>#结果<br>0 alex<br>1 eric<br>2 rain</p>
<p>2)len<br>zero = []<br>for i in li:<br>    print(len(zero),i)<br>    zero.append(i)<br>#结果<br>0 alex<br>1 eric<br>2 rain</p>
<p>3)range<br>for i in range(len(li)):<br>    print(i,li[i])<br>#结果<br>0 alex<br>1 eric<br>2 rain<br> k.请使用 enumrate 输出列表元素和序号（序号从 100 开始）</p>
<p>for index,i in enumerate(li,start=100):<br>    print(index,i)<br>#结果<br>100 alex<br>101 eric<br>102 rain<br>l.请使用 for 循环输出列表的所有元素</p>
<p>for i in li:<br>    print(i)<br>#结果<br>alex<br>eric<br>rain<br> (新)<br>23、写代码，有如下列表，请按照功能要求实现每一个功能<br>li=[“hello”,’seven’,[“mon”,[“h”,”kelly”],’all’],123,446]<br>a. 请输出 “Kelly”</p>
<p>print(li[2][1][1])<br>#结果<br>kelly<br>b.请使用索引找到 ‘all’元素并将其修改为 “ALL”</p>
<p>li[2][2] = “ALL”<br>print(li)<br>#结果<br>[‘hello’, ‘seven’, [‘mon’, [‘h’, ‘kelly’], ‘ALL’], 123, 446]<br>24、写代码，有如下元组，按照要求实现每一个功能<br>tu=(‘alex’,’eric’,’rain’)<br>a.计算元组长度并输出</p>
<p>print(len(tu))<br>#结果<br>3<br>b.获取元组的第2个元素，并输出</p>
<p>print(tu[1])<br>#结果<br>eric<br>c.获取元组的第 1-2个元素，并输出</p>
<p>print(tu[0:2])<br>#结果<br>(‘alex’, ‘eric’)<br>d.请使用 for 输出元组的元素</p>
<p>for i in tu:<br>    print(i)<br>#结果<br>alex<br>eric<br>rain<br>e.请使用 for、len、range 输出元组的索引</p>
<p>#跟22题j列表用法类似<br>for i in range(len(tu)):<br>    print(i,tu[i])<br>#结果<br>0 alex<br>1 eric<br>2 rain<br>f.请使用 enumrate 输出元祖元素和序号（序号从 10 开始）</p>
<p>for index,i in enumerate(tu,start=10):<br>    print(index,i)<br>#结果<br>10 alex<br>11 eric<br>12 rain<br>25、有如下变量，请实现要求的功能<br>tu=(“alex”,[11,22,{“k1”:’v1’,”k2”:[“age”,”name”],”k3”:(11,22,33)},44])<br>a.讲述元祖的特性<br>元祖和列表类似都是有序的从0开始<br>不同的是元祖的元素是不能修改的<br>b.请问 tu 变量中的第一个元素 “alex” 是否可被修改？<br>不能修改<br>c.请问tu变量中的”k2”对应的值是什么类型？是否可以被修改？<br>如果可以，请在其中添加一个元素 “Seven”</p>
<p>print(type(tu[1][2][“k2”]))<br>#结果<br>&lt;class ‘list’&gt;<br>列表类型可以修改<br>tu[1][2][“k2”].append(“seven”)<br>print(tu)<br>#结果<br>(‘alex’, [11, 22, {‘k2’: [‘age’, ‘name’, ‘seven’], ‘k3’: (11, 22, 33), ‘k1’: ‘v1’}, 44])<br>注：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。<br>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，<br>tuple的每个元素，指向永远不变。但指向的这个list本身是可变的！<br>d.请问 tu 变量中的”k3”对应的值是什么类型？是否可以被修改？<br>如果可以，请在其中添加一个元素 “Seven”</p>
<p>print(type(tu[1][2][“k3”]))<br>#结果<br>&lt;class ‘tuple’&gt;<br>#对应值是元祖，不能修改</p>
<p>26、字典<br>dic ={‘k1’:”v1”,”k2”:”v2”,”k3”:[11,22,33]}<br>a.请循环输出所有的 key</p>
<p>for i in dic:<br>    print(i)<br>#结果<br>k1<br>k3<br>k2<br>注：字典是无序的<br>b.请循环输出所有的value</p>
<p>for i in dic:<br>    print(dic[i])<br>#结果<br>[11, 22, 33]<br>v2<br>v1<br>c.请循环输出所有的 key 和 value</p>
<p>for i in dic:<br>    print(i,dic[i])<br>#结果<br>k2 v2<br>k3 [11, 22, 33]<br>k1 v1<br>d.请在字典中添加一个键值对，”k4”:”v4”，输出添加后的字典</p>
<p>dic[“k4”] = “v4”<br>print(dic)<br>#结果<br>{‘k4’: ‘v4’, ‘k2’: ‘v2’, ‘k3’: [11, 22, 33], ‘k1’: ‘v1’}<br>e.请在修改字典中 “k1” 对应的值为 “alex”，输出修改后的字典</p>
<p>dic[‘k1’] = “alex”<br>print(dic)<br>#结果<br>{‘k3’: [11, 22, 33], ‘k1’: ‘alex’, ‘k2’: ‘v2’}<br>f.请在 k3 对应的值中追加一个元素44，输出修改后的字典</p>
<p>dic[“k3”].append(44)<br>print(dic)<br>#结果<br>{‘k2’: ‘v2’, ‘k3’: [11, 22, 33, 44], ‘k1’: ‘v1’}<br>g.请在 k3 对应的值的第1个位置插入个元素18，输出修改后的字典</p>
<p>dic[“k3”].insert(0,18)<br>print(dic)<br>#结果<br>{‘k1’: ‘v1’, ‘k2’: ‘v2’, ‘k3’: [18, 11, 22, 33]}<br> 27、转换<br>a.将字符串 s=”alex” 转换成列表</p>
<p>print(list(s))<br>#结果<br>[‘a’, ‘l’, ‘e’, ‘x’]<br>b.将字符串 s=”alex” 转换成元祖</p>
<p>print(tuple(s))<br>#结果<br>(‘a’, ‘l’, ‘e’, ‘x’)<br>c.将列表 li =[“alex”,”seven”]转换成元组</p>
<p>print(tuple(li))<br>#结果<br>(‘alex’, ‘seven’)<br>d.将元祖 tu =(‘Alex’,”seven”)转换成列表</p>
<p>print(list(tu))<br>#结果<br>[‘Alex’, ‘seven’]<br>e.将列表 li=[“alex”,”seven”]转换成字典且字典的key按照10开始向后递增</p>
<p>dic1 = {}<br>for key,value in enumerate(li,start=10):<br>    dic1[key] = value<br>print(dic1)<br>#结果<br>{10: ‘alex’, 11: ‘seven’}<br> 28、转码<br>n=”老男孩”<br>a.将字符串转换成 utf-8 编码的字节，并输出，然后将该字节再转换成 utf-8 编码字符串，再输出</p>
<p>print(n.encode(“utf-8”))<br>#结果<br>b’\xe8\x80\x81\xe7\x94\xb7\xe5\xad\xa9’</p>
<p>print(n.encode(“utf-8”).decode(“utf-8”))<br>#结果<br>老男孩<br>b.将字符串转换成 gbk 编码的字节，并输出，然后将该字节再转换成 gbk 编码字符串，再输出</p>
<p>print(n.encode(“gbk”))<br>#结果<br>b’\xc0\xcf\xc4\xd0\xba\xa2’</p>
<p>print(n.encode(“gbk”).decode(“gbk”))<br>#结果<br>老男孩<br> 29、求1-100内的所有数的和</p>
<p>#3种方法<br>1)<br>print(sum(range(1,101)))<br>#结果<br>5050</p>
<p>2)<br>SUM = 0<br>for i in range(1,101):<br>    SUM += i<br>print(SUM)<br>#结果<br>5050</p>
<p>3)<br>SUM = 0<br>count = 1<br>while count &lt;= 100:<br>    SUM += count<br>    count += 1<br>print(SUM)<br>#结果<br>5050<br>30、元素分类<br>有如下值集合 [11,22,33,44,55,66,77,88,99,90]，<br>将所有大于66的值保存至字典的第一个 key中，<br>将小于66的值保存至第二个 key 的值中。<br>即：{‘k1’:大于 66 的所有值,’k2’:小于66 的所有值}</p>
<p>dic = {“k1”:[],<br>       “k2”:[]}<br>aa = set([11,22,33,44,55,66,77,88,99,90])<br>for i in aa:<br>    if i&gt;= 66:<br>        dic[“k1”].append(i)<br>    else:<br>        dic[“k2”].append(i)<br>print(dic)<br>结果<br>{‘k1’: [66, 99, 77, 88, 90], ‘k2’: [33, 11, 44, 22, 55]}<br>31、购物车<br>功能要求：<br>要求用户输入总资产，例如： 2000<br>显示商品列表，让用户根据序号选择商品，加入购物车<br>购买，如果商品总额大于总资产，提示账户余额不足，否则，购买成功。<br>goods = [<br>{“name”:”电脑”,”price”:1999},<br>{“name”:”鼠标”,”price”:10},<br>{“name”:”游艇”,”price”:20},<br>{“name”:”美女”,”price”:98},<br>]</p>
<p>shop_cart = []<br>goods    =    [<br>{“name”:”电脑”,”price”:1999},<br>{“name”:”鼠标”,”price”:10},<br>{“name”:”游艇”,”price”:20},<br>{“name”:”美女”,”price”:98},<br>]<br>while True:<br>    salary = input(“请输入用户余额[quit]:”)<br>    if salary.isdigit():<br>        salary = int(salary)<br>        break<br>    elif salary == “quit”:<br>        exit(“不想购买”)<br>    else:<br>        print(“please the enter number”)<br>while True:<br>    print(“shop list”.center(50, ‘*’))<br>    for index,i in enumerate(goods):<br>        print(index,i)<br>    choose_number = input(“请输入购买商品编号[quit]:”)<br>    if choose_number.isdigit():<br>    choose_number = int(choose_number)<br>        product_list = []<br>        if 0 &lt;= choose_number &lt;= len(goods):<br>            product_list.append(goods[choose_number])<br>            if salary &gt;= product_list[0][“price”]:<br>              shop_cart.append(goods[choose_number])<br>              salary -= product_list[0][‘price’]<br>              print(“当前购买的商品”,product_list,”当前用户余额\033[1;31m{salary}\033[0m”.format(salary=salary))<br>            else:<br>                print(“余额不足”)<br>        else:<br>            print(“无效的商品编号”)<br>    elif choose_number.lower() == ‘quit’:</p>
<pre><code>    print(&quot;购买的商品&quot;.center(50,&quot;*&quot;))
    for y in shop_cart:
        print(y)
    exit()
else:
    print(&quot;无效的输入&quot;)</code></pre><p>#注:简易的购物车，还能继续优化</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests实现模拟用户登录</title>
    <url>/requests%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-了解cookie和session"><a href="#1-了解cookie和session" class="headerlink" title="1. 了解cookie和session"></a>1. 了解cookie和session</h1><p>首先一定要先了解到cookie和session是什么，这是后面理解网站交互，模拟用户登录的基础。</p>
<h2 id="1-1-无状态协议：Http"><a href="#1-1-无状态协议：Http" class="headerlink" title="1.1. 无状态协议：Http"></a>1.1. 无状态协议：Http<img src="/images/2020/07/13/d7d748a0-16cb-4121-8bd8-3c1db8cb19b8.png" alt="image.png"></h2><p>如上图所示，HTTP协议 是无状态的协议，用户浏览服务器上的内容，只需要发送页面请求，服务器返回内容。对于服务器来说，并不关心，也并不知道是哪个用户的请求。对于一般浏览性的网页来说，没有任何问题。<br>但是，现在很多的网站，是需要用户登录的。以淘宝为例：比如说某个用户想购买一个产品，当点击 “ 购买按钮 ” 时，由于HTTP协议 是无状态的，那对于淘宝来说，就不知道是哪个用户操作的。<br>为了实现这种用户标记，服务器就采用了cookie这种机制来识别具体是哪一个用户的访问。</p>
<h2 id="1-2-了解cookie"><a href="#1-2-了解cookie" class="headerlink" title="1.2. 了解cookie"></a>1.2. 了解cookie</h2><p><img src="/images/2020/07/13/7cefe427-bf7c-4f89-9f4f-9f566edd0ce1.png" alt="image.png"><br>如图，为了实现用户标记，在Http无状态请求的基础之上，我们需要在请求中携带一些用户信息（比如用户名之类，这些信息是服务器发送到本地浏览器的，但是服务器并不存储这些信息），这就是cookie机制。如下图所示，在登录马蜂窝网站之后，就可以看到浏览器已经保存了一些cookie信息（chrome浏览器为例）：<img src="/images/2020/07/13/c72725a8-0ff3-4222-ba9c-3c3955e725d5.png" alt="image.png"><br>需要注意的是：cookie信息是保存在本地浏览器里面的，服务器上并不存储相关的信息。 在发送请求时，cookie的这些内容是放在 Http协议中的header 字段中进行传输的。 <img src="/images/2020/07/13/33b9b9e0-a1f0-45b9-8c5e-4938172eb02d.png" alt="image.png">几乎现在所有的网站都会发送一些 cookie信息过来，当用户请求中携带了cookie信息，服务器就可以知道是哪个用户的访问了，从而不需要再使用账户和密码登录。<br>但是，刚才也提到了，cookie信息是直接放在Http协议的header中进行传输的，看得出来，这是个隐患！一旦别人获取到你的cookie信息（截获请求，或者使用你的电脑），那么他很容易从cookie中分析出你的用户名和密码。为了解决这个隐患，所以有了session机制。</p>
<h2 id="1-3-了解session"><a href="#1-3-了解session" class="headerlink" title="1.3. 了解session"></a>1.3. 了解session</h2><p>刚才提到了cookie不安全，所以有了session机制。简单来说（每个框架都不一样，这只是举一个通用的实现策略），整过过程是这样：<br>服务器根据用户名和密码，生成一个session ID，存储到服务器的数据库中。<br>用户登录访问时，服务器会将对应的session ID发送给用户（本地浏览器）。<br>浏览器会将这个session ID存储到cookie中，作为一个键值项。<br>以后，浏览器每次请求，就会将含有session ID的cookie信息，一起发送给服务器。<br>服务器收到请求之后，通过cookie中的session ID，到数据库中去查询，解析出对应的用户名，就知道是哪个用户的请求了。</p>
<h3 id="1-3-1-看一下Django是如何实现session机制的，来加深对session的了解"><a href="#1-3-1-看一下Django是如何实现session机制的，来加深对session的了解" class="headerlink" title="1.3.1. 看一下Django是如何实现session机制的，来加深对session的了解"></a>1.3.1. 看一下Django是如何实现session机制的，来加深对session的了解</h3><p><img src="/images/2020/07/13/bc5b3849-887e-4c5c-aaaf-b742bf339192.png" alt="image.png">)<img src="/images/2020/07/13/2eb28ab3-5a98-4083-ac50-40196d13f847.png" alt="image.png"> Session_key：服务器给用户返回的ID<br>    Session_data：一段加密的文字。用户名，密码，一些其他的用户信息。把这些信息生成一段字符串，是加密的<br>    expire_date：django后台会设置过期时间。 主要是担心session被黑客截取，那就一直可以用，盗用数据。<br>第二步，当用户登录时，服务器会给本地浏览器返回一些cookie信息，包括session ID。<br><img src="/images/2020/07/13/0c6c5760-017e-4acf-9fd2-6886cbdb6a22.png" alt="image.png">第三步：以后浏览器每次访问时，浏览器都会把 session ID带过来，这样服务器不需要知道你的用户名，就知道是哪个用户的访问了。<br>服务器是如何把sessionID转换成用户名的？<br><img src="/images/2020/07/13/7e9506a3-a4de-4a74-bdb2-0d378c587c23.png" alt="image.png">如上图所示，在Django中，需要对session进行配置。这个INSTALLED_APPS 是会对每次request和response进行拦截，拦截到浏览器发送过来的request时，找到其中的session信息，然后到数据库中进行查询，找到session_data，再做解密，就知道所有的用户信息了，取出user信息。新建完Django项目之后，这个sessions信息就配置好了。如果注释掉这一个session配置，自动登录机制就会失效，无法使用。</p>
<h2 id="1-4-总结一下"><a href="#1-4-总结一下" class="headerlink" title="1.4. 总结一下"></a>1.4. 总结一下</h2><p>cookie 在客户端（本地浏览器），session 在服务器端。cookie是一种浏览器本地存储机制。存储在本地浏览器中，和服务器没有关系。每次请求，用户会带上本地cookie的信息。这些cookie信息也是服务器之前发送给浏览器的，或者是用户之前填写的一些信息。<br>Cookie有不安全机制。 你不能把所有的用户信息都存在本地，一旦被别人窃取，就知道你的用户名和密码，就会很危险。所以引入了session机制。<br>服务器在发送id时引入了一种session的机制，很简单，就是根据用户名和密码，生成了一段随机的字符串，这段字符串是有过期时间的。<br>一定要注意：session是服务器生成的，存储在服务器的数据库或者文件中，然后把sessionID发送给用户，用户存储在本地cookie中。每次请求时，把这个session ID带给服务器，服务器根据session ID到数据库中去查询，找到是哪个用户，就可以对用户进行标记了。<br>session 的运行依赖 session ID，而 session ID 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，那么同时 session 也会失效（但是可以通过其它方式实现，比如在url中传递 session ID）<br>用户验证这种场合一般会用 session。 因此，维持一个会话的核心就是客户端的唯一标识，即session ID</p>
<h1 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h1><p>python 3.6.1<br>requests 2.14.2 （通过pip list查看）</p>
<h1 id="3-模拟登录马蜂窝网站"><a href="#3-模拟登录马蜂窝网站" class="headerlink" title="3. 模拟登录马蜂窝网站"></a>3. 模拟登录马蜂窝网站</h1><p>马蜂窝：<a href="http://www.mafengwo.cn/" target="_blank" rel="noopener">http://www.mafengwo.cn/</a></p>
<h2 id="3-1-分析用户登录流程"><a href="#3-1-分析用户登录流程" class="headerlink" title="3.1. 分析用户登录流程"></a>3.1. 分析用户登录流程</h2><p>这里会用到两个小技巧<br>第一，先使用一个错误的用户名和密码来登录，这样就可以清晰的看到这个登录请求有post哪些数据，post到哪个url。因为如果使用正确的用户名和密码登录，一旦登录成功，就会直接跳转到其他页面，页面和请求都会被刷新。很难找出原始的请求信息<br><img src="/images/2020/07/13/dd15389f-9d3b-4dd0-92a5-a08509e02109.png" alt="image.png"><br>第二，在截取请求的地方，勾选Preserve log，保留跳转前的请求数据。<br><img src="/images/2020/07/13/c9467950-caaa-4d91-a019-a9973de2ac8e.png" alt="image.png"><br>截取到的请求如下：<br><img src="/images/2020/07/13/1fd354c2-3673-48cd-8e71-5f84cc7b3599.png" alt="image.png">)<img src="/images/2020/07/13/162b0a1a-1473-41f9-852e-0cbd5ac680ae.png" alt="image.png"><br>#提取到的请求信息：<br>Headers：<br>    Request URL:<a href="https://passport.mafengwo.cn/login/" target="_blank" rel="noopener">https://passport.mafengwo.cn/login/</a><br>    Request Method:POST<br>    origin:<a href="https://passport.mafengwo.cn" target="_blank" rel="noopener">https://passport.mafengwo.cn</a><br>    referer:<a href="https://passport.mafengwo.cn/" target="_blank" rel="noopener">https://passport.mafengwo.cn/</a><br>    User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)     Chrome/63.0.3239.132 Safari/537.36    </p>
<p>Form Data:<br>    passport:13725168940<br>    password:aaa00000000</p>
<h2 id="3-2-模拟登录"><a href="#3-2-模拟登录" class="headerlink" title="3.2. 模拟登录"></a>3.2. 模拟登录</h2><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><figure class="highlight plain"><figcaption><span>requests</span></figcaption><table><tr><td class="code"><pre><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    # 马蜂窝模仿 登录</span><br><span class="line">    print (&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    responseRes &#x3D; requests.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line"># 从返回结果来看，有登录成功</span><br><span class="line">    mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">一般来说，调试期，判断是否登录成功的最简单的方法：就是直接打印登录之后的text内容，使用错误的用户名登录，和使用正确的用户名登录，对比打印输出的内容。</span><br><span class="line">后面通过学习我们会提出相对来说更好的判断方式…</span><br></pre></td></tr></table></figure>
<h2 id="3-3-使用cookie访问站点"><a href="#3-3-使用cookie访问站点" class="headerlink" title="3.3. 使用cookie访问站点"></a>3.3. 使用cookie访问站点</h2><p>在上一步，我们已经成功登录到马蜂窝网站了。那么接下来要如何访问站点中其他页面呢。前面提到过，网站是通过cookie和session来标记是哪个用户访问的。所以，在我们登录成功之后，有很重要的一步，就是我们需要把cookie保存下来，下一次请求这个站点的页面时，把这个cookie带过去。</p>
<h3 id="3-3-1-保存cookie信息"><a href="#3-3-1-保存cookie信息" class="headerlink" title="3.3.1. 保存cookie信息"></a>3.3.1. 保存cookie信息</h3><p>修改代码，加入cookie保存机制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"></span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line"></span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    # 马蜂窝模仿 登录</span><br><span class="line">    print(&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line"></span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    # 使用session直接post请求</span><br><span class="line">    responseRes &#x3D; mafengwoSession.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line">    # 登录成功之后，将cookie保存在本地文件中，好处是，以后再去获取马蜂窝首页的时候，就不需要再走mafengwoLogin的流程了，因为已经从文件中拿到cookie了</span><br><span class="line">    mafengwoSession.cookies.save()</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # 从返回结果来看，有登录成功</span><br><span class="line">    # mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">cookie保存结果如下：</span><br><span class="line"># 文件：mafengwoCookies.txt</span><br><span class="line">#LWP-Cookies-2.0</span><br><span class="line">Set-Cookie3: __today_login&#x3D;1; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-16 15:56:15Z&quot;; httponly&#x3D;None; version&#x3D;0</span><br><span class="line">Set-Cookie3: mafengwo&#x3D;&quot;0a60e1a04f6a6f5555f0e285602b5b17_94281374_5aab641fb23d42.37804626_5aab641fb23dc3.28763728&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-06-13 06:25:03Z&quot;; httponly&#x3D;None; version&#x3D;0</span><br><span class="line">Set-Cookie3: mfw_uuid&#x3D;&quot;5aab641f-b789-96ef-736d-48640285f4c0&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2019-03-16 06:25:03Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: oad_n&#x3D;&quot;a%3A3%3A%7Bs%3A3%3A%22oid%22%3Bi%3A1029%3Bs%3A2%3A%22dm%22%3Bs%3A20%3A%22passport.mafengwo.cn%22%3Bs%3A2%3A%22ft%22%3Bs%00009%3A%222018-03-16+14%3A28%3A47%22%3B%7D&quot;; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-23 06:25:03Z&quot;; version&#x3D;0</span><br><span class="line">Set-Cookie3: uol_throttle&#x3D;94281374; path&#x3D;&quot;&#x2F;&quot;; domain&#x3D;&quot;.mafengwo.cn&quot;; path_spec; domain_dot; expires&#x3D;&quot;2018-03-16 06:35:03Z&quot;; version&#x3D;0</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-使用cookie登录"><a href="#3-3-2-使用cookie登录" class="headerlink" title="3.3.2. 使用cookie登录"></a>3.3.2. 使用cookie登录</h3><p>为了测试访问页面时，是否处于登录状态。有一个比较巧妙的方法：就是直接访问一个需要登录后，才可见的地址。比如说涉及到用户信息的页面。下面以 “我的路线” 页面为例：<a href="http://www.mafengwo.cn/plan/route.php" target="_blank" rel="noopener">http://www.mafengwo.cn/plan/route.php</a><br>这是登录状态后见到的页面：<br><img src="/images/2020/07/13/a95ff71a-ddb6-4f42-88c5-d510422b36ae.png" alt="image.png"><br><img src="/images/2020/07/13/61fa814a-a32c-4240-9203-f3bf8f937b35.png" alt="image.png"><br>如果是 非登录状态，会自动跳转（重定向302）到 用户登录页面<br><img src="/images/2020/07/13/a499ba31-7049-4d2d-9f2d-9ef1e431ccd8.png" alt="image.png"><br>所以，我们可以用这个页面判断cookie登录是否成功，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"></span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line"></span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def isLoginStatus():</span><br><span class="line">    # 通过访问个人中心页面的返回状态码来判断是否为登录状态</span><br><span class="line"></span><br><span class="line">    routeUrl &#x3D; &quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;route.php&quot;</span><br><span class="line">    # 下面有两个关键点</span><br><span class="line">        # 第一个是header，如果不设置，会返回500的错误</span><br><span class="line">        # 第二个是allow_redirects，如果不设置，session访问时，服务器返回302，</span><br><span class="line">        # 然后session会自动重定向到登录页面，获取到登录页面之后，变成200的状态码</span><br><span class="line">        # allow_redirects &#x3D; False  就是不允许重定向</span><br><span class="line">    responseRes &#x3D; mafengwoSession.get(routeUrl, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;isLoginStatus &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    if responseRes.status_code !&#x3D; 200:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    mafengwoSession.cookies.load()</span><br><span class="line">    isLogin &#x3D; isLoginStatus()</span><br><span class="line">    print(f&quot;is login mafengwo &#x3D; &#123;isLogin&#125;&quot;)</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        # 按照之前保存过的mafengwoCookies.txt登录，属于登录状态：</span><br><span class="line">        user cookielib in python3.</span><br><span class="line">        isLoginStatus &#x3D; 200</span><br><span class="line">        is login mafengwo &#x3D; True</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        # 如果把mafengwoCookies.txt中的信息修改掉之后，就无法登录了，属于非登录状态了</span><br><span class="line">        user cookielib in python3.</span><br><span class="line">        isLoginStatus &#x3D; 302</span><br><span class="line">        is login mafengwo &#x3D; False</span><br><span class="line">    &#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-最终形成的登录模式"><a href="#3-4-最终形成的登录模式" class="headerlink" title="3.4. 最终形成的登录模式"></a>3.4. 最终形成的登录模式</h2><p>因为cookie是有有效期的，所以没法做到一次登录，终生有效。所以，一般的登录模式，就是：<br>第一步：先尝试cookie登录<br>第二步：如果cookie无法登录成功，就使用用户名密码登录，将新的cookie保存下来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line"># python2 和 python3的兼容代码</span><br><span class="line">try:</span><br><span class="line">    # python2 中</span><br><span class="line">    import cookielib</span><br><span class="line">    print(f&quot;user cookielib in python2.&quot;)</span><br><span class="line">except:</span><br><span class="line">    # python3 中</span><br><span class="line">    import http.cookiejar as cookielib</span><br><span class="line">    print(f&quot;user cookielib in python3.&quot;)</span><br><span class="line"># session代表某一次连接</span><br><span class="line">mafengwoSession &#x3D; requests.session()</span><br><span class="line"># 因为原始的session.cookies 没有save()方法，所以需要用到cookielib中的方法LWPCookieJar，这个类实例化的cookie对象，就可以直接调用save方法。</span><br><span class="line">mafengwoSession.cookies &#x3D; cookielib.LWPCookieJar(filename &#x3D; &quot;mafengwoCookies.txt&quot;)</span><br><span class="line">userAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&quot;</span><br><span class="line">header &#x3D; &#123;</span><br><span class="line">    # &quot;origin&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&quot;,</span><br><span class="line">    &quot;Referer&quot;: &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;&quot;,</span><br><span class="line">    &#39;User-Agent&#39;: userAgent,</span><br><span class="line">&#125;</span><br><span class="line"># 马蜂窝模仿 登录</span><br><span class="line">def mafengwoLogin(account, password):</span><br><span class="line">    print(&quot;开始模拟登录马蜂窝&quot;)</span><br><span class="line">    postUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.mafengwo.cn&#x2F;login&#x2F;&quot;</span><br><span class="line">    postData &#x3D; &#123;</span><br><span class="line">        &quot;passport&quot;: account,</span><br><span class="line">        &quot;password&quot;: password,</span><br><span class="line">    &#125;</span><br><span class="line">    # 使用session直接post请求</span><br><span class="line">    responseRes &#x3D; mafengwoSession.post(postUrl, data &#x3D; postData, headers &#x3D; header)</span><br><span class="line">    # 无论是否登录成功，状态码一般都是 statusCode &#x3D; 200</span><br><span class="line">    print(f&quot;statusCode &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    print(f&quot;text &#x3D; &#123;responseRes.text&#125;&quot;)</span><br><span class="line">    # 登录成功之后，将cookie保存在本地文件中，好处是，以后再去获取马蜂窝首页的时候，就不需要再走mafengwoLogin的流程了，因为已经从文件中拿到cookie了</span><br><span class="line">    mafengwoSession.cookies.save()</span><br><span class="line"># 通过访问个人中心页面的返回状态码来判断是否为登录状态</span><br><span class="line">def isLoginStatus():</span><br><span class="line">    routeUrl &#x3D; &quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;route.php&quot;</span><br><span class="line">    # 下面有两个关键点</span><br><span class="line">        # 第一个是header，如果不设置，会返回500的错误</span><br><span class="line">        # 第二个是allow_redirects，如果不设置，session访问时，服务器返回302，</span><br><span class="line">        # 然后session会自动重定向到登录页面，获取到登录页面之后，变成200的状态码</span><br><span class="line">        # allow_redirects &#x3D; False  就是不允许重定向</span><br><span class="line">    responseRes &#x3D; mafengwoSession.get(routeUrl, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;isLoginStatus &#x3D; &#123;responseRes.status_code&#125;&quot;)</span><br><span class="line">    if responseRes.status_code !&#x3D; 200:</span><br><span class="line">        return False</span><br><span class="line">    else:</span><br><span class="line">        return True</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    # 第一步：尝试使用已有的cookie登录</span><br><span class="line">    mafengwoSession.cookies.load()</span><br><span class="line">    isLogin &#x3D; isLoginStatus()</span><br><span class="line">    print(f&quot;is login mafengwo &#x3D; &#123;isLogin&#125;&quot;)</span><br><span class="line">    if isLogin &#x3D;&#x3D; False:</span><br><span class="line">        # 第二步：如果cookie已经失效了，那就尝试用帐号登录</span><br><span class="line">        print(f&quot;cookie失效，用户重新登录...&quot;)</span><br><span class="line">        mafengwoLogin(&quot;13756567832&quot;, &quot;000000001&quot;)</span><br><span class="line">    resp &#x3D; mafengwoSession.get(&quot;http:&#x2F;&#x2F;www.mafengwo.cn&#x2F;plan&#x2F;fav_type.php&quot;, headers &#x3D; header, allow_redirects &#x3D; False)</span><br><span class="line">    print(f&quot;resp.status &#x3D; &#123;resp.status_code&#125;&quot;)</span><br><span class="line"># 第一次运行程序的输出：</span><br><span class="line"># 由于第一次还没有生成cookie，所以需要用账户登录一次</span><br><span class="line">user cookielib in python3.</span><br><span class="line">isLoginStatus &#x3D; 302</span><br><span class="line">is login mafengwo &#x3D; False</span><br><span class="line">cookie失效，用户重新登录...</span><br><span class="line">开始模拟登录马蜂窝</span><br><span class="line">statusCode &#x3D; 200</span><br><span class="line">……………………</span><br><span class="line">resp.status &#x3D; 200</span><br><span class="line"># 第二次运行程序的输出：</span><br><span class="line"># 第二次，就直接使用cookie登录了，不再需要使用帐号登录</span><br><span class="line"></span><br><span class="line">user cookielib in python3.</span><br><span class="line">isLoginStatus &#x3D; 200</span><br><span class="line">is login mafengwo &#x3D; True</span><br><span class="line">resp.status &#x3D; 200</span><br><span class="line"> </span><br><span class="line">注意事项</span><br><span class="line">try:</span><br><span class="line">        _se.cookies.load()</span><br><span class="line">        isLogin &#x3D; isLoginStatus()</span><br><span class="line">    except FileNotFoundError:</span><br><span class="line">        isLogin &#x3D; False</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python四种验证码解决思路</title>
    <url>/python%E5%9B%9B%E7%A7%8D%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1.输入式验证码<br>这种验证码主要是通过用户输入图片中的字母、数字、汉字等进行验证。如下图<br>   <img src="/images/2020/07/12/1da1261d-7475-4dc7-881e-5ec5e0c54c7a.png" alt="image.png">图1 <img src="/images/2020/07/12/0ab1686e-60ef-4c4d-a270-81f201490751.png" alt="image.png">图2</p>
<p>解决思路：这种是最简单的一种，只要识别出里面的内容，然后填入到输入框中即可。这种识别技术叫OCR，这里我们推荐使用Python的第三方库，tesserocr。对于没有什么背影影响的验证码如图2，直接通过这个库来识别就可以。但是对于有嘈杂的背景的验证码这种，直接识别识别率会很低，遇到这种我们就得需要先处理一下图片，先对图片进行灰度化，然后再进行二值化，再去识别，这样识别率会大大提高。</p>
<p>2.滑动式验证码<br>这种是将备选碎片直线滑动到正确的位置，如下图<br>  <img src="/images/2020/07/12/4d51b6de-7a6a-4c5b-ac9b-c7a3fe476435.png" alt="image.png">)<img src="/images/2020/07/12/356a818d-718f-4a6f-9576-ff91724f8c4c.png" alt="image.png"></p>
<p>解决思路：对于这种验证码就比较复杂一点，但也是有相应的办法。我们直接想到的就是模拟人去拖动验证码的行为，点击按钮，然后看到了缺口  的位置，最后把拼图拖到缺口位置处完成验证。</p>
<p>第一步：点击按钮。然后我们发现，在你没有点击按钮的时候那个缺口和拼图是没有出现的，点击后才出现，这为我们找到缺口的位置提供了灵感。</p>
<p>第二步：拖到缺口位置。我们知道拼图应该拖到缺口处，但是这个距离如果用数值来表示？通过我们第一步观察到的现象，我们可以找到缺口的位置。这里我们可以比较两张图的像素，设置一个基准值，如果某个位置的差值超过了基准值，那我们就找到了这两张图片不一样的位置，当然我们是从那块拼图的右侧开始并且从左到右，找到第一个不一样的位置时就结束，这是的位置应该是缺口的left，所以我们使用selenium拖到这个位置即可。这里还有个疑问就是如何能自动的保存这两张图？这里我们可以先找到这个标签，然后获取它的location和size，然后 top，bottom，left，right = location[‘y’] ,location[‘y’]+size[‘height’]+ location[‘x’] + size[‘width’]  ,然后截图，最后抠图填入这四个位置就行。具体的使用可以查看selenium文档，点击按钮前抠张图，点击后再抠张图。最后拖动的时候要需要模拟人的行为，先加速然后减速。因为这种验证码有行为特征检测，人是不可能做到一直匀速的，否则它就判定为是机器在拖动，这样就无法通过验证了。</p>
<p>3.点击式的图文验证 和  图标选择<br>图文验证：通过文字提醒用户点击图中相同字的位置进行验证。</p>
<p>图标选择： 给出一组图片，按要求点击其中一张或者多张。借用万物识别的难度阻挡机器。</p>
<p>这两种原理相似，只不过是一个是给出文字，点击图片中的文字，一个是给出图片，点出内容相同的图片。</p>
<p>这两种没有特别好的方法，只能借助第三方识别接口来识别出相同的内容，推荐一个超级鹰，把验证码发过去，会返回相应的点击坐标。</p>
<p>然后再使用selenium模拟点击即可。具体怎么获取图片和上面方法一样。</p>
<p>4.宫格验证码</p>
<p><img src="/images/2020/07/12/b3c00b2d-0545-4167-93f6-fc6272641263.png" alt="image.png"><br>这种就很棘手，每一次出现的都不一样，但是也会出现一样的。而且拖动顺序都不一样。</p>
<p>但是我们发现不一样的验证码个数是有限的，这里采用模版匹配的方法。我觉得就好像暴力枚举，把所有出现的验证码保存下来，然后挑出不一样的验证码，按照拖动顺序命名，我们从左到右上下到下，设为1,2,3,4。上图的滑动顺序为4,3,2,1所以我们命名4_3_2_1.png，这里得手动搞。当验证码出现的时候，用我们保存的图片一一枚举，与出现这种比较像素，方法见上面。如果匹配上了，拖动顺序就为4,3,2,1。然后使用selenium模拟即可。</p>
<p>python中的验证码识别库PyTesser</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>最强下载神器IDM</title>
    <url>/%E6%9C%80%E5%BC%BA%E4%B8%8B%E8%BD%BD%E7%A5%9E%E5%99%A8IDM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>Internet Download Manager，简称 IDM，是国外的一款优秀下载工具。目前凭借着下载计算的速度优势在外媒网站中均受好评，现在已被多数国人熟知。Internet Download Manager 提升你的下载速度最多达5倍，安排下载时程，带有续传功能，可以恢复因为断线、网络问题、计算机当机甚至无预警的停电导致下传到一半的资料。国外的Internet Download Manager简称IDM是一款下载利器，不限速，界面简洁好看，还能自动识别网页视频，无多余菜单弹窗!并且支持IE，Firefox，Chrome等浏览器。<br>IDM具有动态文件分割、多重下载点技术，而且它会重复使用现有的联机，而不需再重新联机登入一遍。智能in-speed技术会动态地将所有设定应用到某种联机类型，以充分利用下载速度。IDM支持下载队列、防火墙、代理服务器和映摄服务器、重新导向、cookies、需要验证的目录，以及各种不同的服务器平台，它紧密地与Internet Explorer和Netscape Communicator结合，自动地处理你的下载需求。此外，IDM还具有下载逻辑最佳化功能、检查病毒，以及多种偏好设定。</p>
<h2 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h2><p>下载后解压&gt;找到!绿化卸载.bat&gt;右键以管理员身份运行。<br><img src="/images/2020/07/06/c308e0eb-9028-44a9-a29f-75c3d655b29b.png" alt="image.png"><br>输入1,回车确定安装。<br><img src="/images/2020/07/06/b22014f1-eca2-455f-9453-7b1b75de180a.png" alt="image.png"><br>强烈建议创建快捷方式。<br><img src="/images/2020/07/06/c769bb97-c8c1-4c03-b5b3-3539988b0b68.png" alt="image.png"><br>主界面就是这个样子了，还算简洁，最起码没广告。<br><img src="/images/2020/07/06/e072019d-34b3-4f6f-aeca-80fdf540613e.png" alt="image.png"><br>下面是个人推荐下载地址：<a href="http://soft.ucbug.com/uploads/soft/linshi/wlrj/ucbug.com-idm.rar" target="_blank" rel="noopener">idm下载</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>IDM</tag>
      </tags>
  </entry>
  <entry>
    <title>元数据库安装配置</title>
    <url>/%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、下载Mysql-yum-仓库"><a href="#1、下载Mysql-yum-仓库" class="headerlink" title="1、下载Mysql yum 仓库"></a>1、下载Mysql yum 仓库</h1><p><img src="/images/2020/07/04/2f5b1866-edd9-4e32-bff4-8d5464bf4a97.png" alt="image.png"></p>
<h1 id="2、添加Mysql-yum-仓库"><a href="#2、添加Mysql-yum-仓库" class="headerlink" title="2、添加Mysql yum 仓库"></a>2、添加Mysql yum 仓库</h1><p><img src="/images/2020/07/04/e5596132-16ce-4edc-a81a-dae6715c3173.png" alt="image.png"></p>
<h1 id="3、让安装包可用"><a href="#3、让安装包可用" class="headerlink" title="3、让安装包可用"></a>3、让安装包可用</h1><p><img src="/images/2020/07/04/466e06c3-1fba-4786-b8b6-1179ca7db91d.png" alt="image.png"></p>
<h1 id="4、安装Mysql"><a href="#4、安装Mysql" class="headerlink" title="4、安装Mysql"></a>4、安装Mysql</h1><p><img src="/images/2020/07/04/5cd8776c-1cd8-413a-bacf-138f85b63c91.png" alt="image.png"></p>
<h1 id="5、启动Mysql服务"><a href="#5、启动Mysql服务" class="headerlink" title="5、启动Mysql服务"></a>5、启动Mysql服务</h1><p><img src="/images/2020/07/04/4e17769e-f249-4501-94ff-534e2319ed57.png" alt="image.png"></p>
<h1 id="6、修改Mysql数据库"><a href="#6、修改Mysql数据库" class="headerlink" title="6、修改Mysql数据库"></a>6、修改Mysql数据库</h1><p><img src="/images/2020/07/04/f3ceef96-7015-4999-8f5e-0a66d4195f01.png" alt="image.png"></p>
<h1 id="7、设置数据库访问权限"><a href="#7、设置数据库访问权限" class="headerlink" title="7、设置数据库访问权限"></a>7、设置数据库访问权限</h1><p><img src="/images/2020/07/04/c33b7323-7b83-4ac2-af77-c285cab2d029.png" alt="image.png"><br><img src="/images/2020/07/04/980eddfc-3321-48e2-a33e-6bf0ad381013.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>HIve</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>在数据挖掘中，海量的原始数据中存在着这大量不完整（有缺失值）、不一致、有异常的数据，严重影响到数据挖掘建模的执行效率，甚至可能导致挖掘结果的偏差，所以进行数据清洗就显得尤为重要，数据清洗完成后接着进行或者同时进行数据继承、转换、规约等一系列的处理，该过程就是数据预处理。<br>      数据预处理一方面是要提高数据的质量，另一个方面是要让数据更好地适应特定挖掘技术或工具。统计发现，在数据挖掘的过程中，数据预处理工作量占到了整个过程的60%<br>数据预处理框架图<br><img src="/images/2020/07/14/5671eb5f-c0c8-4354-9ea3-efc6d4c1808d.png" alt="image.png">数据清洗<br>      数据清洗主要是删除原始数据集中的无关数据、重复数据，平滑噪声数据，筛选掉与挖掘主题无关的数据，处理缺失值、异常值等。</p>
<h1 id="缺失值的处理"><a href="#缺失值的处理" class="headerlink" title="缺失值的处理"></a>缺失值的处理</h1><p>处理缺失值的方法可以分为三类：<br>删除记录<br>数据插补<br>不处理<br> ::: hljs-center</p>
<p>常用的插补方法</p>
<p>:::</p>
<p>  <img src="/images/2020/07/14/b818c5b9-ac4c-410a-b403-8db8a77f99cd.png" alt="image.png"><br>插值法：<br>拉格朗日插值法<br>Hermite插值<br>牛顿插值法<br>分段插值<br>样条插值<br>      如果通过简单的删除小部分记录达到既定的目标，那么删除含有缺失值的记录的方法是最有效的。然而，这种方法却有很大的局限性。它是以减少历史数据来换取数据的完备，会造成资源的大量浪费，将丢弃了大量隐藏在这些记录中的信息。尤其是在数据集本来就包含很少纪录的情况下，删除少量记录可能会严重影响到分析结果的客观性和正确性。一些模型可以将缺失值视作一种特殊的取值，允许直接在含有缺失值的数据上进行建模。<br>异常值处理<br>      在数据预处理时，异常值是否剔除，需视具体情况而定，因为有些异常值可能蕴含着有用的信息。<br>::: hljs-center</p>
<p>异常值处理常用方法 </p>
<p>:::<br>  <img src="/images/2020/07/14/6c47b79b-0d9e-42b6-a5c8-5feabc961821.png" alt="image.png">将含有异常值的记录直接删除的方法简单易行，但缺点也很明显，在观测值很少的情况下，这种删除会造成样本量不足，可能会改变变量的原有分布，从而造成分析结果的不准确。视为缺失值处理的好处是可以利用现有变量的信息，对异常值（缺失值）进行填补。<br>      在很多情况下，要先分析异常值出现的可能原因，在判断异常值是否应该舍弃，如果是正确的数据，可以直接在具有异常值的数据集上进行挖掘建模。</p>
<h1 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h1><p>数据挖掘需要的数据往往分布在不同的数据源中，数据集成就是将多个数据源合并存放在一个一致的数据存储（数据仓库）中的过程。<br>      在数据集成时，来自多个数据源的现实世界实体的表达形式是不一样的，有可能不匹配，要考虑实体识别问题和属性冗余问题，从而将数据源在最底层上加以转换、提炼和集成。<br>实体识别<br>实体识别是指从不同数据源识别出现实世界的实体，它的任务是统一不同源数据的矛盾之处，常见形式如下：</p>
<h1 id="同名异义"><a href="#同名异义" class="headerlink" title="同名异义"></a>同名异义</h1><p>数据源A中的属性ID和数据源中的属性ID分别描述的是学生编号和科目编号，即描述的是不同的实体。</p>
<h1 id="异名同义"><a href="#异名同义" class="headerlink" title="异名同义"></a>异名同义</h1><p>数据源A中dt和数据源B中的date都是描述日期的。</p>
<h1 id="单位不统一"><a href="#单位不统一" class="headerlink" title="单位不统一"></a>单位不统一</h1><p>描述同一个实体分别用的是国际单位和中国传统的计量单位，检测和解决这些冲突就是实体识别的任务。</p>
<h1 id="冗余属性识别"><a href="#冗余属性识别" class="headerlink" title="冗余属性识别"></a>冗余属性识别</h1><p>数据冗余情况：<br>同一属性多次出现。<br>同一属性命名不一致导致重复。<br>      仔细整合不同数据源减少甚至避免数据冗余与不一致，从而提高数据挖掘的速度和质量。对于冗余属性要先分析，检测到后再将其删除。<br>      有些冗余属性可以用相关分析检测。给定两个数值型A和B，根据其属性值，用相关系数度量一个属性在多大程度上蕴含另一个属性。</p>
<h1 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h1><p>数据变换主要是对数据进行规范化处理，将数据转化成“适当的”形式，以适用于挖掘任务及算法的需要。</p>
<p>方便置信区间分析或者可视化 (缩放数据， 对称分布)。<br>为了获取更容易解释的特征 (获取线性特征)。<br>降低数据的维度或者复杂度。<br>方便使用简单的回归模型。<br>简单的数据变换<br>      简单的函数变换常用来将不具有正态分布非数据变换成具有正态分布的数据。在时间序列分析中，有时简单的对数变换或者差分运算就可以将非平稳序列转换成平稳序列。<br>::: hljs-center</p>
<p>常用简单的函数表</p>
<p>:::<br><img src="/images/2020/07/14/b3e224bb-c0f8-474e-9ea3-e3d750a4d55f.png" alt="image.png"></p>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><p>数据规范化（归一化）处理是数据挖掘的一项基础工作。不同评价指标往往具有不同的量纲， 数之间的差别可能很大，不进行处理会影响到数据分析的结果。为了消除指标之间的量纲和取值范围差异的影响，需要进行标准化处理，将数据按照比例进行缩放，使之落入特定的区域，便于进行综合分析。<br>把数据映射到[0,1]的区间中。<br>把有量纲形式变成无量纲形式 。<br>::: hljs-center</p>
<p>常用的规范化方法</p>
<p>:::<br><img src="/images/2020/07/14/66d45649-4790-4442-a499-6282b49d09de.png" alt="image.png"></p>
<h1 id="连续属性离散化"><a href="#连续属性离散化" class="headerlink" title="连续属性离散化"></a>连续属性离散化</h1><p> 一些数据挖掘算法，特别是某些分类算法（ID3算法、Apripri算法等）、要求数据是分类属性形式。这样，常常需要将连续属性变换换成分类属性，即连续属性离散化。</p>
<h3 id="离散化过程"><a href="#离散化过程" class="headerlink" title="离散化过程"></a>离散化过程</h3><p>连续属性的离散化就是在数据的取值范围内设定若干个离散的划分点，将取值范围划分为一些离散化的区间，最后用不同的符号或整数值代表落在每个子区间中的数据值。所以，离散化涉及两个任务：确定分类数以及如何将连续属性值映射到这些分类值。</p>
<h3 id="常用的离散化方法"><a href="#常用的离散化方法" class="headerlink" title="常用的离散化方法"></a>常用的离散化方法</h3><p><img src="/images/2020/07/14/03344607-bc7c-4beb-8e45-80892039794b.png" alt="image.png"></p>
<h1 id="属性构造"><a href="#属性构造" class="headerlink" title="属性构造"></a>属性构造</h1><p>在数据挖掘的过程中，为了提取更有用的信息，挖掘更深层次的模式，提高挖掘结果的精度，需要利用已有的属性集构造出新的属性，并加入到现有的属性集合中。</p>
<h1 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h1><p>在大数据集上进行复杂的数据分析和挖掘需要很长的时间，数据归约产生更小但保持原数据完整性的新数据集。在规约后的数据集上进行分析和挖掘将更有效率。<br>数据规约的意义：</p>
<p>降低无效、错误数据对建模的影响，提高建模的准确性。<br>少量且代表性的数据将大幅缩减数据挖掘所需的时间。<br>降低存储数据的成本</p>
<h1 id="属性规约"><a href="#属性规约" class="headerlink" title="属性规约"></a>属性规约</h1><p> 属性规约通过属性合并来创建新属性维数，或者直接通过删除不相关（维）来减少数据维数，从而提高数据挖掘的效率、降低计算成本。属性规约的目标是寻找出最小的属性子集并确保新数据子集的概率分布尽可能地接近原来数据集的概率分布。<br><img src="/images/2020/07/14/a178a096-56b8-4052-a5de-ed5c2d47eec2.png" alt="image.png"></p>
<h1 id="数值规约"><a href="#数值规约" class="headerlink" title="数值规约"></a>数值规约</h1><p>数值规约值通过选择替代的、较少的数据来减少数据量，包括有参数和无参数方法两类。有参数方法是使用一个模型来评估数据，只需存放参数，而不需要存放实际数据，例如回归和对数线性模型。无参数方法就需要存放实际数据。</p>
<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>直方图使用分箱来近似数据分布，是一种流行的数据归约形式。</p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>聚类技术将数据元组（即记录，数据表中的一行）视为对象。它将对象划分为簇，使一个簇中的对象相互“相似”，而与其他簇中的对象“相异”。在数据规约中，用数据的簇替换实际数据。该技术的有效性依赖于簇的定义是否符合数据的分布性质。</p>
<h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h3><p>抽样也是一种数据规约技术，它用比原始数据小得多的随机样本（子集）表示原始数据集。假定原始数据集D包含N个元组，可以采用抽样方法对D进行抽样。<br><strong>s个样本无放回简单随机抽样<br>s个样本有放回简单随机抽样<br>聚类抽样<br>分层抽样</strong></p>
<h3 id="参数回归"><a href="#参数回归" class="headerlink" title="参数回归"></a>参数回归</h3><p>简单线性模型和对数线性模型可以用来近似描述给定的数据。线性模型对数据建模，使之拟合一条直线。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫开发步骤流程简析</title>
    <url>/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B%E7%AE%80%E6%9E%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>爬虫的基本流程:<br>0.（预处理）<br>1.发起请求：<br>通过HTTP库向目标站点发起请求，即发送一个Request，请求可以包含额外的headers、data等信息，然后等待服务器响应。这个请求的过程就像我们打开浏览器，在浏览器地址栏输入网址：<a href="http://www.baidu.com，然后点击回车。这个过程其实就相当于浏览器作为一个浏览的客户端，向服务器端发送了" target="_blank" rel="noopener">www.baidu.com，然后点击回车。这个过程其实就相当于浏览器作为一个浏览的客户端，向服务器端发送了</a> 一次请求。</p>
<p>2.获取响应内容：<br>如果服务器能正常响应，我们会得到一个Response，Response的内容便是所要获取的内容，类型可能有HTML、Json字符串，二进制数据(图片，视频等）等类型。这个过程就是服务器接收客户端的请求，进过解析发送给浏览器的网页HTML文件。</p>
<p>3.解析内容：<br>得到的内容可能是HTML，可以使用正则表达式，网页解析库进行解析。也可能是Json，可以直接转为Json对象解析。可能是二进制数据，可以做保存或者进一步处理。这一步相当于浏览器把服务器端的文件获取到本地，再进行解释并且展现出来。</p>
<p>4.保存数据：<br>保存的方式可以是把数据存为文本，也可以把数据保存到数据库，或者保存为特定的jpg，mp4 等格式的文件。这就相当于我们在浏览网页时，下载了网页上的图片或者视频。</p>
<p>Scrapy爬虫开发流程一般包括如下步骤：<br>1）确定项目需求。<br>2）创建Scrapy项目。<br>3）定义页面提取的Item。<br>4）分析被爬对象页面。<br>5）编写爬取网站的Spider并提取Item。<br>6）编写Item Pipeline来存储提取到的Item（即数据）。<br>7）运行爬虫。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化VMware ESXi 6.7服务器与vCenter的安装与配置</title>
    <url>/%E8%99%9A%E6%8B%9F%E5%8C%96VMware-ESXi-6-7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EvCenter%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="vSphere虚拟化架构"><a href="#vSphere虚拟化架构" class="headerlink" title="vSphere虚拟化架构"></a>vSphere虚拟化架构</h2><p>vSphere是VNware公司在2001年基于云计算推出的一套企业级虚拟化解决方案、核心组件为ESXi。如今，经历了5个版本的改进，已经实现了虚拟化基础架构、高可用性、集中管理、性能监控等一体化解决方案。</p>
<p><a href="https://baike.baidu.com/item/vSphere" target="_blank" rel="noopener">🔗详情点击</a><br>安装步骤<br>首先打开VMware workstation软件创建新的虚拟机并且采用自定义安装</p>
<p><img src="/images/2020/07/07/7bcaec75-a70d-4022-8dae-06470eea358e.png" alt="image.png">选择稍后安装一个操作系统</p>
<p><img src="/images/2020/07/07/ba64b5a3-4c77-4dc0-a5b0-520fd5a019e3.png" alt="image.png"><br>选择操作系统，点击VMware ESX选择版本为VMware ESXI 6.x的那个版本<br><img src="/images/2020/07/07/52325d15-2bb8-4365-a243-bcf2a2c7e94b.png" alt="image.png"></p>
<p>命名虚拟机名称并且选择虚拟机在自己电脑上的位置</p>
<p><img src="/images/2020/07/07/4d9bfa35-0585-4084-bd18-8a1f6112f329.png" alt="image.png"></p>
<p>选择处理器的配置，这里可以根据自己的需求选择</p>
<p><img src="/images/2020/07/07/582516fd-62d2-4f34-930b-4affae4836bc.png" alt="image.png"></p>
<p>选择网络类型，这里使用桥接网络</p>
<p><img src="/images/2020/07/07/40f98f7d-5cb1-480c-990e-6fdf135422ad.png" alt="image.png"></p>
<p>选择I/O控制器类型，选择为推荐的准虚拟化SCSI<br><img src="/images/2020/07/07/c1eca22a-0cc3-4174-affd-984f151bddd1.png" alt="image.png"></p>
<p>选择虚拟磁盘类型为SCSI</p>
<p><img src="/images/2020/07/07/c5389142-35cc-4c6c-a69b-51c5d63367b2.png" alt="image.png"></p>
<p>选择创建新的虚拟磁盘</p>
<p><img src="/images/2020/07/07/9640b004-2432-4158-a397-dec33ea63378.png" alt="image.png"></p>
<p>指定虚拟磁盘的容量大小，在这分配200GB空间具体根据自己需求</p>
<p><img src="/images/2020/07/07/13b1e0e0-15b4-4421-b092-1771ccd33db9.png" alt="image.png"></p>
<p>先不要点击完成，因为ESXI的镜像还没有挂载，点击自定义硬件</p>
<p><img src="/images/2020/07/07/9acb422c-bb75-4641-9cba-368d7d3b08b3.png" alt="image.png"></p>
<p>选择挂载自己电脑上的ISO镜像文件</p>
<p><img src="/images/2020/07/07/2f268ad5-32c3-4201-ab25-21d9ef1995b3.png" alt="image.png"></p>
<p>选择完成后点击关闭然后再点击完成，然后打开虚拟机。会出现如下的界面</p>
<p><img src="/images/2020/07/07/2721abcb-397e-4de2-a996-417821228115.png" alt="image.png"></p>
<p>等待片刻，按回车键开始安装</p>
<p><img src="/images/2020/07/07/684104e1-b05f-4598-9464-a5f5fe68eec8.png" alt="image.png"></p>
<p>按F11键接受协议并继续</p>
<p><img src="/images/2020/07/07/acd04bff-ce39-4224-b2c2-1fd8af495b0e.png" alt="image.png"></p>
<p>选择安装的位置并按回车键继续安装</p>
<p><img src="/images/2020/07/07/b4fef258-7294-423b-9c21-799f75910d8d.png" alt="image.png"></p>
<p>选择键盘布局，这里选择使用默认.</p>
<p><img src="/images/2020/07/07/ed2f25b5-61d0-4356-99d8-4d5e58406a6f.png" alt="image.png"></p>
<p>为root用户创建密码，需要选择安全性较高的的数字字母字符组合来作为密码</p>
<p><img src="/images/2020/07/07/0e84667b-7d98-416c-a5f6-5aa007215693.png" alt="image.png"></p>
<p>按下F11键开始正式的安装</p>
<p><img src="/images/2020/07/07/cc5559a3-0c8f-44ed-89ba-9d325796711b.png" alt="image.png"></p>
<p>接下来会进入这个安装进度界面，</p>
<p><img src="/images/2020/07/07/f93b1b24-bad1-4ee9-9fc8-281e35314a0a.png" alt="image.png"></p>
<p>等待2-3分钟后，安装完成按回车键重启系统</p>
<p><img src="/images/2020/07/07/ecf55256-b7fb-4dd9-91dd-a6a7b6be77fa.png" alt="image.png"></p>
<p>重启完成后界面如下</p>
<p><img src="/images/2020/07/07/dfd6d466-a9bf-47b3-9b89-aa2e43e81e13.png" alt="image.png"></p>
<p>对系统进行配置，按F2键然后输入刚才创建的密码进入配置界面。</p>
<p><img src="/images/2020/07/07/a1911cf5-a23e-4888-949c-fb69d27926c2.png" alt="image.png"></p>
<p>Configure Managment Network来配置网络。配置静态IPV4地址</p>
<p><img src="/images/2020/07/07/a2e19773-2470-4510-a3ad-9b8c668ad5b8.png" alt="image.png"></p>
<p>配置DNS服务器地址</p>
<p><img src="/images/2020/07/07/afe524fe-8c4d-4b29-a4c2-ee7b78c3fc92.png" alt="image.png"></p>
<p>按ESC键离开，会提示下面这个界面按Y同意重启网络</p>
<p><img src="/images/2020/07/07/ba6e1153-bf2a-43fc-9f3a-5b5c5715fd06.png" alt="image.png"></p>
<p>Troubleshooting Options来开启SSH与Shell</p>
<p><img src="/images/2020/07/07/e7bf600e-d87d-4925-9416-c9a2b87b4c88.png" alt="image.png"></p>
<p>到此为止配置上基本完成了，下面在浏览器地址栏中输入刚才配置的IP地址192.168.1.103使用web界面对ESXI进行控制。使用root用户登录</p>
<p><img src="/images/2020/07/07/805d2a5b-a964-414f-9ea9-a1bd16ea090a.png" alt="image.png"></p>
<h2 id="vCenter"><a href="#vCenter" class="headerlink" title="vCenter"></a>vCenter</h2><p>Vcenter一般指 VMware vCenter™ Server<br>VMware vCenterServer 提供了一个可伸缩、可扩展的平台，为 虚拟化管理奠定了基础。 VMware vCenter Server（以前称为 VMware VirtualCenter），可集中管理 VMware vSphere 环境，与其他管理平台相比，极大地提高了 IT 管理员对虚拟环境的控制。<br>VMware vCenter Server：提高在虚拟基础架构每个级别上的集中控制和可见性，通过主动管理发挥 vSphere 潜能，是一个具有广泛合作伙伴体系支持的可伸缩、可扩展平台。</p>
<p><a href="https://baike.baidu.com/item/vCenter" target="_blank" rel="noopener">🔗详情点击</a></p>
<h2 id="安装vCenter"><a href="#安装vCenter" class="headerlink" title="安装vCenter"></a>安装vCenter</h2><p>vCenter主要有两种:一种是基于Windows的vCenter server它的功能和性能更强大！还有一种就是基于嵌入式linux的vCenter server appliance，使用小的虚拟化环境（主机小于50台，虚拟机少于1000个），使用这个部署起来更简单快捷。当然如果更大的虚拟化环境，就一定需要基于Windows的vCenter server了。随着版本的更迭，vmware去windows化越来越明显了，很多高级功能（跨集群迁移，vcsa ha等等）只有以vcsa方式部署才可能实现了，vcsa部署维护都要比传统windows+vCenterServer+MySQL方便，就是web管理界面还是不如原来的vsphere client好用。</p>
<p><img src="/images/2020/07/07/94d52b8e-3461-48f4-b2eb-55904c4bcb07.png" alt="image.png"></p>
<p>安装vCenter server appliance<br>在Windows上装载镜像</p>
<p><img src="/images/2020/07/07/6802d789-1363-4e95-bbc0-50ce42e61865.png" alt="image.png">vcenter</p>
<p>然后打开vcsa-ui-installer那个文件夹，在打开下面的那个win32目录，双击installer.exe即可开始安装。</p>
<p><img src="/images/2020/07/07/09f8bcee-c68a-4ccf-84fd-5044d88f44e1.png" alt="image.png"></p>
<p>安装分为两个阶段</p>
<p><img src="/images/2020/07/07/37a72090-47e6-4105-a532-033f3f918931.png" alt="image.png"></p>
<p>勾选“我接受许可协议条款”</p>
<p><img src="/images/2020/07/07/8675eb99-4a6b-40c9-ba2d-c3d772a0c3bf.png" alt="image.png"></p>
<p>选择嵌入式 Platform Services Controller</p>
<p><img src="/images/2020/07/07/de346651-a018-40c6-becb-e9fa0c4cd9d6.png" alt="image.png"></p>
<p>指定VCSA 6.7部署到ESXi主机或vCenter Server</p>
<p><img src="/images/2020/07/07/b5aa3d3f-f48e-4dd7-add0-3ca5526442c2.png" alt="image.png"></p>
<p>会出现警告直接点是即可，下面配置VCSA 6.7虚拟机名称以及root密码。</p>
<p><img src="/images/2020/07/07/d80444a6-392b-4d2f-9494-22cbfc09f861.png" alt="image.png"></p>
<p>选择部署大小</p>
<p><img src="/images/2020/07/07/982b0164-426e-41ce-9c30-f3d53d4e5611.png" alt="image.png"></p>
<p>选择VCSA 6.7虚拟机存储<br><img src="/images/2020/07/07/23af1a0c-f0f9-4691-8588-f992f7ddfa27.png" alt="image.png"></p>
<p>之前的设置部署大小为300GB，可是由于自己电脑没有那么大的存储空间23333。只好这样先装了</p>
<p>配置VCSA 6.7虚拟机网络</p>
<p><img src="/images/2020/07/07/5b2ed2da-a716-40ff-af8d-a8d10d689648.png" alt="image.png"></p>
<p>确认第1阶段参数<br><img src="/images/2020/07/07/24db6c5c-6722-4993-a53c-81b785c5e1c0.png" alt="image.png"></p>
<p>开始第一阶段部署，部署的时间取决于物理服务器性能</p>
<p><img src="/images/2020/07/07/bece36f1-bc18-47dc-8405-53040e150d31.png" alt="image.png"></p>
<p>第一阶段完成，开始第二阶段</p>
<p><img src="/images/2020/07/07/b5a19232-1905-483a-a025-774640aabf5c.png" alt="image.png">)<img src="/images/2020/07/07/b1a61faa-02c6-4dcf-98e0-914eb7b7b8c2.png" alt="image.png"></p>
<p>配置系统时间</p>
<p><img src="/images/2020/07/07/887f5517-f9ab-438a-864e-dd3a25df5a60.png" alt="image.png"></p>
<p>这里选择跟ESXI主机同步。当然也可以选择和NTP服务器时间相同。根据自己需求选择是否启用SSH</p>
<p>SSO配置</p>
<p><img src="/images/2020/07/07/70404f34-797b-40e8-bcf5-0eb919ae80f9.png" alt="image.png"></p>
<p>确认是否加入CEIP</p>
<p><img src="/images/2020/07/07/8ef42ed4-fe92-46f9-b779-d664d390fddc.png" alt="image.png"></p>
<p>确认参数</p>
<p><img src="/images/2020/07/07/dc757e61-bf85-4c8d-86c3-8b747756bbca.png" alt="image.png"></p>
<p>点击确定开始第二阶段部署</p>
<p><img src="/images/2020/07/07/3d2e2f64-798e-49de-a438-10300e20e5e0.png" alt="image.png"></p>
<p>开始部署</p>
<p><img src="/images/2020/07/07/c8b3f7ee-4f93-4767-bbe7-9dc1a9769cd9.png" alt="image.png"></p>
<p>安装完成</p>
<p><img src="/images/2020/07/07/2b9c0c64-3393-4a03-8698-251a490b39df.png" alt="image.png"></p>
<p>打开VCSA 6.7控制台界面</p>
<p><img src="/images/2020/07/07/fc431e8c-134e-4c80-815e-11947dc87f21.png" alt="image.png"></p>
<p>在浏览器中输入VCSA 6.7的IP地址进行访问，VCSA 6.7提供H5以及FLASH两个选择，从初步使用看，H5功能比VCSA 6.5得到增强</p>
<p><img src="/images/2020/07/07/60dabf12-51c5-482b-bada-a28431efe7e8.png" alt="image.png"></p>
<p>输入SSO登录</p>
<p><img src="/images/2020/07/07/f1bf8161-91af-49c5-bcbc-38266e4e0da8.png" alt="image.png"></p>
<p>VCSA 6.7 登录成功后界面如下</p>
<p><img src="/images/2020/07/07/e6ee7699-a220-4c5c-b623-f908d886cb41.png" alt="image.png"></p>
<p>访问VMware vCenter Server Appliance Web</p>
<p><img src="/images/2020/07/07/b6aca240-9f68-458e-af9a-152944842c58.png" alt="image.png"><br><img src="/images/2020/07/07/bacd3236-4d20-49ee-9626-92d3659a8197.png" alt="image.png"></p>
<h3 id="安装vCenter-server"><a href="#安装vCenter-server" class="headerlink" title="安装vCenter server"></a>安装vCenter server</h3><p>当镜像挂载之后打开安装程序<br><img src="/images/2020/07/07/db865e34-e4f3-4f69-84fa-e8c2b4c58b9a.png" alt="image.png"></p>
<p>点击下一步继续安装<br><img src="/images/2020/07/07/e84fd03e-7965-4c54-b490-4a93597c3554.png" alt="image.png"></p>
<p>选择接受许可协议条款</p>
<p><img src="/images/2020/07/07/31fdd3d2-80cb-460a-92d4-3e41f898555a.png" alt="image.png"></p>
<p>选择部署类型，在这先暂时选择嵌入式部署。在以后会对外部部署进行安装。</p>
<p><img src="/images/2020/07/07/1883039b-fa49-4e1a-a0a5-de6570885525.png" alt="image.png"></p>
<p>配置系统网络名称，输入windows server的IP地址</p>
<p><img src="/images/2020/07/07/8a5cdc57-002d-4176-8c27-831431c6133c.png" alt="image.png"></p>
<p>vCenter Single Sign-On 配置</p>
<p><img src="/images/2020/07/07/686dd69f-b8a6-44c2-966e-b786055f1183.png" alt="image.png"></p>
<p>选择vCenter Server服务账户</p>
<p><img src="/images/2020/07/07/2ebc8f5a-de2e-4816-b0bf-a6cf3b344d21.png" alt="image.png"></p>
<p>数据库设置，选择嵌入式数据库</p>
<p><img src="/images/2020/07/07/36a4cd7e-234e-4925-8bd7-0cfd71769622.png" alt="image.png"></p>
<p>配置端口</p>
<p><img src="/images/2020/07/07/8e9f85b8-43ff-4a41-9a1b-b4e15402d5fa.png" alt="image.png"></p>
<p>选择安装目录</p>
<p><img src="/images/2020/07/07/508f6244-b468-418a-9c95-742d4abbbc22.png" alt="image.png"></p>
<p>加入客户体验提升计划</p>
<p><img src="/images/2020/07/07/19c6e02f-679e-4cab-baa9-f807bdb4da78.png" alt="image.png"></p>
<p>点击完成开始安装<br><img src="/images/2020/07/07/2084f5c3-1edf-4a35-8c5e-e52fe501833d.png" alt="image.png"></p>
<p>安装过程时间根据机器性能决定，大概10分钟左右</p>
<p><img src="/images/2020/07/07/1f1c81e6-2e97-476f-89c0-0b93723ceca4.png" alt="image.png"></p>
<p>安装完成</p>
<p><img src="/images/2020/07/07/87be7579-5906-4db4-b081-6576152bcfc1.png" alt="image.png"></p>
<p>在客户机访问vSphere Web Client</p>
<p><img src="/images/2020/07/07/f12110f1-5829-4eb9-9aab-720145a342f1.png" alt="image.png"></p>
<p>输入刚才设置的账号密码，然后登录成功</p>
<p><img src="/images/2020/07/07/7087312b-e0be-458a-8785-04dae733ff83.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>网页基础</title>
    <url>/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="1-网页的组成"><a href="#1-网页的组成" class="headerlink" title="1. 网页的组成"></a>1. 网页的组成</h2><p>网页可以分为三大部分——HTML、CSS和JavaScript。如果把网页比作一个人的话，HTML相当于骨架，JavaScript相当于肌肉，CSS相当于皮肤，三者结合起来才能形成一个完善的网页。下面我们分别来介绍一下这三部分的功能。<br>(1) HTML<br>HTML是用来描述网页的一种语言，其全称叫作Hyper Text Markup Language，即超文本标记语言。网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是HTML。不同类型的文字通过不同类型的标签来表示，如图片用img标签表示，视频用video标签表示，段落用p标签表示，它们之间的布局又常通过布局标签div嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。<br>在Chrome浏览器中打开百度，右击并选择“检查”项（或按F12键），打开开发者模式，这时在Elements选项卡中即可看到网页的源代码，如图2-9所示。<br> <img src="/images/2020/07/05/eb2e6bab-77a3-435d-9a73-001dc077439a.png" alt="image.png">图2-9 源代码<br>这就是HTML，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。<br>(2) CSS<br>HTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里借助了CSS。<br>CSS，全称叫作Cascading Style Sheets，即层叠样式表。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。<br>CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。<br>图2-9的右侧即为CSS，例如：</p>
<pre><code>#head_wrapper.s-ps-islite .s-p-top {
position: absolute;
bottom: 40px;
width: 100%;
height: 181px;}</code></pre><p>就是一个CSS样式。大括号前面是一个CSS选择器，此选择器的意思是首先选中id为head_wrapper且class为s-ps-islite的节点，然后再选中其内部的class为s-p-top的节点。大括号内部写的就是一条条样式规则，例如position指定了这个元素的布局方式为绝对布局，bottom指定元素的下边距为40像素，width指定了宽度为100%占满父元素，height则指定了元素的高度。也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上CSS选择器，这就代表这个样式对CSS选择器选中的元素生效，元素就会根据此样式来展示了。<br>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中（其后缀为css）。在HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。<br>(3) JavaScript<br>JavaScript，简称JS，是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。<br>JavaScript通常也是以单独的文件形式加载的，后缀为js，在HTML中通过script标签即可引入，例如：</p>
<pre><code>&lt;script src=&quot;jquery-2.1.0.js&quot;&gt;&lt;/script&gt;</code></pre><p>综上所述，HTML定义了网页的内容和结构，CSS描述了网页的布局，JavaScript定义了网页的行为。</p>
<h2 id="2-网页的结构"><a href="#2-网页的结构" class="headerlink" title="2. 网页的结构"></a>2. 网页的结构</h2><p>我们首先用例子来感受一下HTML的基本结构。新建一个文本文件，名称可以自取，后缀为html，内容如下：</p>
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>This is a Demo</title>
    <meta name="generator" content="Hexo 4.2.1"></head>
    <body>
        <div id="container">
            <div class="wrapper">
                <h2 class="title">Hello World</h2>
                <p class="text">Hello, this is a paragraph.</p>
            </div>
        </div>
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>

<p>这就是一个最简单的HTML实例。开头用DOCTYPE定义了文档类型，其次最外层是html标签，最后还有对应的结束标签来表示闭合，其内部是head标签和body标签，分别代表网页头和网页体，它们也需要结束标签。head标签内定义了一些页面的配置和引用，如：</p>
<pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><p>它指定了网页的编码为UTF-8。<br>title标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。body标签内则是在网页正文中显示的内容。div标签定义了网页中的区块，它的id是container，这是一个非常常用的属性，且id的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个div标签，它的class为wrapper，这也是一个非常常用的属性，经常与CSS配合使用来设定样式。然后此区块内部又有一个h2标签，这代表一个二级标题。另外，还有一个p标签，这代表一个段落。在这两者中直接写入相应的内容即可在网页中呈现出来，它们也有各自的class属性。<br>将代码保存后，在浏览器中打开该文件，可以看到如图2-10所示的内容。<br> <img src="/images/2020/07/05/0f0f252b-4e61-4a92-be73-b14db897e7a4.png" alt="image.png">   图2-10 运行结果<br>可以看到，在选项卡上显示了This is a Demo字样，这是我们在head中的title里定义的文字。而网页正文是body标签内部定义的各个元素生成的，可以看到这里显示了二级标题和段落。<br>这个实例便是网页的一般结构。一个网页的标准形式是html标签内嵌套head和body标签，head内定义网页的配置和引用，body内定义网页的正文。</p>
<h2 id="3-节点树及节点间的关系"><a href="#3-节点树及节点间的关系" class="headerlink" title="3. 节点树及节点间的关系"></a>3. 节点树及节点间的关系</h2><p>在HTML中，所有标签定义的内容都是节点，它们构成了一个HTML DOM树。<br>我们先看下什么是DOM，DOM是W3C（万维网联盟）的标准，其英文全称Document Object Model，即文档对象模型。它定义了访问HTML和XML文档的标准：<br>W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。<br>W3C DOM标准被分为3个不同的部分。<br>•    核心DOM： 针对任何结构化文档的标准模型。<br>•    XML DOM：针对XML文档的标准模型。<br>•    HTML DOM：针对HTML文档的标准模型。<br>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。<br>•    整个文档是一个文档节点；<br>•    每个HTML元素是元素节点；<br>•    HTML元素内的文本是文本节点；<br>•    每个HTML属性是属性节点；<br>•    注释是注释节点。<br>HTML DOM将HTML文档视作树结构，这种结构被称为节点树，如图2-11所示。<br><img src="/images/2020/07/05/b93058d4-c3ce-475c-91c2-ff3c37e04702.png" alt="image.png"> 图2-11 节点树<br>通过HTML DOM，树中的所有节点均可通过JavaScript访问，所有HTML节点元素均可被修改，也可以被创建或删除。<br>节点树中的节点彼此拥有层级关系。我们常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。<br>在节点树中，顶端节点称为根（root）。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。图2-12展示了节点树以及节点之间的关系。<img src="/images/2020/07/05/cd6a66aa-25f6-47aa-aa7d-498ef629f263.png" alt="image.png"><br> 图2-12 节点树及节点间的关系<br>本段参考W3SCHOOL，链接：<a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp。" target="_blank" rel="noopener">http://www.w3school.com.cn/htmldom/dom_nodes.asp。</a></p>
<h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4. 选择器"></a>4. 选择器</h2><p>我们知道网页由一个个节点组成，CSS选择器会根据不同的节点设置不同的样式规则，那么怎样来定位节点呢？<br>在CSS中，我们使用CSS选择器来定位节点。例如，上例中div节点的id为container，那么就可以表示为#container，其中#开头代表选择id，其后紧跟id的名称。另外，如果我们想选择class为wrapper的节点，便可以使用.wrapper，这里以点（.）开头代表选择class，其后紧跟class的名称。另外，还有一种选择方式，那就是根据标签名筛选，例如想选择二级标题，直接用h2即可。这是最常用的3种表示，分别是根据id、class、标签名筛选，请牢记它们的写法。<br>另外，CSS选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如#container .wrapper p则代表先选择id为container的节点，然后选中其内部的class为wrapper的节点，然后再进一步选中其内部的p节点。另外，如果不加空格，则代表并列关系，如div#container .wrapper p.text代表先选择id为container的div节点，然后选中其内部的class为wrapper的节点，再进一步选中其内部的class为text的p节点。这就是CSS选择器，其筛选功能还是非常强大的。<br>另外，CSS选择器还有一些其他语法规则，具体如表2-4所示。<br>表2-4 CSS选择器的其他语法规则<br><img src="/images/2020/07/05/8bf1bfc8-f09c-4e68-8bbf-2d1834b60323.png" alt="image.png"><br><img src="/images/2020/07/05/5545f3ee-025c-4211-a5f0-430207508533.png" alt="image.png"><br><img src="/images/2020/07/05/74d97db9-d198-4c8b-b0d8-1339287fe2ef.png" alt="image.png"><br><img src="/images/2020/07/05/20d2ccdb-41e5-48af-b32d-fc1529239b6c.png" alt="image.png"><br><img src="/images/2020/07/05/3bbc1032-ae0f-4b4c-bf4d-d402da270711.png" alt="image.png"><br>另外，还有一种比较常用的选择器是XPath，这种选择方式后面会详细介绍。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基本原理</title>
    <url>/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p>
<h2 id="1-爬虫概述"><a href="#1-爬虫概述" class="headerlink" title="1. 爬虫概述"></a>1. 爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序，下面概要介绍一下。<br>(1) 获取网页<br>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。<br>前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。所以，最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来，那么这个流程怎样实现呢？总不能手工去截取网页源码吧？<br>不用担心，Python提供了许多库来帮助我们实现这个操作，如urllib、requests等。我们可以用这些库来帮助我们实现HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的Body部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。<br>(2) 提取信息<br>获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。<br>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如Beautiful Soup、pyquery、lxml等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。<br>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。<br>(3) 保存数据<br>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或JSON文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。<br>(4) 自动化程序<br>说到自动化程序，意思是说爬虫可以代替人来完成这些操作。首先，我们手工当然可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，肯定还是要借助程序。爬虫就是代替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p>
<h2 id="2-能抓怎样的数据"><a href="#2-能抓怎样的数据" class="headerlink" title="2. 能抓怎样的数据"></a>2. 能抓怎样的数据</h2><p>在网页中我们能看到各种各样的信息，最常见的便是常规网页，它们对应着HTML代码，而最常抓取的便是HTML源代码。<br>另外，可能有些网页返回的不是HTML代码，而是一个JSON字符串（其中API接口大多采用这样的形式），这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取更加方便。<br>此外，我们还可以看到各种二进制数据，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。<br>另外，还可以看到各种扩展名的文件，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。<br>上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取。</p>
<h2 id="3-JavaScript渲染页面"><a href="#3-JavaScript渲染页面" class="headerlink" title="3. JavaScript渲染页面"></a>3. JavaScript渲染页面</h2><p>有时候，我们在用urllib或requests抓取网页时，得到的源代码实际和浏览器中看到的不一样。<br>这是一个非常常见的问题。现在网页越来越多地采用Ajax、前端模块化工具来构建，整个网页可能都是由JavaScript渲染出来的，也就是说原始的HTML代码就是一个空壳，例如：<br> <figure class="highlight plain"><figcaption><span>html></span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">         &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">         &lt;title&gt;This is a Demo&lt;&#x2F;title&gt;</span><br><span class="line">     &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">         &lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;app.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></p>
<p>body节点里面只有一个id为container的节点，但是需要注意在body节点后引入了app.js，它便负责整个网站的渲染。<br>在浏览器中打开这个页面时，首先会加载这个HTML内容，接着浏览器会发现其中引入了一个app.js文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JavaScript代码，而JavaScript则会改变HTML中的节点，向其添加内容，最后得到完整的页面。<br>但是在用urllib或requests等库请求当前页面时，我们得到的只是这个HTML代码，它不会帮助我们去继续加载这个JavaScript文件，这样也就看不到浏览器中的内容了。<br>这也解释了为什么有时我们得到的源代码和浏览器中看到的不一样。<br>因此，使用基本HTTP请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台Ajax接口，也可使用Selenium、Splash这样的库来实现模拟JavaScript渲染。<br>后面，我们会详细介绍如何采集JavaScript渲染的网页。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>详解python命名空间和作用域</title>
    <url>/%E8%AF%A6%E8%A7%A3python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1、典型案例"><a href="#1、典型案例" class="headerlink" title="1、典型案例"></a>1、典型案例</h1><p>先从几个典型的案例来看下名称空间及作用域对python代码运行的影响，请看下面几个代码实例及其执行结果，是否符合你的预期。<br>代码1：块作用域<br>if True:<br>    i = 1<br>print i<br>执行结果： 1<br>代码2：函数作用域<br>def f():<br>    i = 1<br>f()<br>print i<br>执行结果：执行报错“NameError: name ‘cc’ is not defined”</p>
<p>代码3：静态作用域<br>i = 1<br>def test():<br>    i += 1<br>test()<br>执行结果：执行报错“UnboundLocalError: local variable ‘i’ referenced before assignment”</p>
<p>代码4：静态作用域<br>i = 1<br>def g():<br>print i<br>print i<br>def f():<br>    i = 2<br>    g()<br>f()　<br>执行结果： 1<br> 将i = 2放在g()后面会不会起作用？<br>代码5：闭包、全局作用域<br>i = 1<br>def f():<br>    i = 2<br>def g():<br>        print i<br>    return g<br>func = f()<br>func()<br>print i<br>执行结果：2    1<br>PS:python2.1之前执行该代码会报错，闭包(嵌套作用域)是在之后引入的概念，内部函数g()只能访问本函数中的命名空间、全局命名空间、内建命名空间，无法访问外部调用函数的命名空间。</p>
<h1 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h1><p>【定义】<br>    名称到对象的映射。命名空间是一个字典的实现，键为变量名，值是变量对应的值。各个命名空间是独立没有关系的，一个命名空间中不能有重名，但是不同的命名空间可以重名而没有任何影响。</p>
<p>【分类】<br>    python程序执行期间会有2个或3个活动的命名空间（函数调用时有3个，函数调用结束后2个）。按照变量定义的位置，可以划分为以下3类：<br>    Local，局部命名空间，每个函数所拥有的命名空间，记录了函数中定义的所有变量，包括函数的入参、内部定义的局部变量。<br>    Global，全局命名空间，每个模块加载执行时创建的，记录了模块中定义的变量，包括模块中定义的函数、类、其他导入的模块、模块级的变量与常量。<br>    Built-in，python自带的内建命名空间，任何模块均可以访问，放着内置的函数和异常。</p>
<p>【生命周期】<br>    Local（局部命名空间）在函数被调用时才被创建，但函数返回结果或抛出异常时被删除。（每一个递归函数都拥有自己的命名空间）。<br>    Global（全局命名空间）在模块被加载时创建，通常一直保留直到python解释器退出。<br>    Built-in（内建命名空间）在python解释器启动时创建，一直保留直到解释器退出。</p>
<pre><code>各命名空间创建顺序：python解释器启动 -&gt;创建内建命名空间 -&gt; 加载模块 -&gt; 创建全局命名空间 -&gt;函数被调用 -&gt;创建局部命名空间
各命名空间销毁顺序：函数调用结束 -&gt; 销毁函数对应的局部命名空间 -&gt; python虚拟机（解释器）退出 -&gt;销毁全局命名空间 -&gt;销毁内建命名空间
python解释器加载阶段会创建出内建命名空间、模块的全局命名空间，局部命名空间是在运行阶段函数被调用时动态创建出来的，函数调用结束动态的销毁的。</code></pre><h1 id="3、作用域"><a href="#3、作用域" class="headerlink" title="3、作用域"></a>3、作用域</h1><p>【定义】<br>    作用域是针对变量而言，指申明的变量在程序里的可应用范围。或者称为变量的可见性。</p>
<p>【分类】<br>    只有函数、类、模块会产生作用域，代码块不会产生作用域（参考代码1）。作用域按照变量的定义位置可以划分为4类：<br>    Local(函数内部)局部作用域<br>    Enclosing（嵌套函数的外层函数内部）嵌套作用域（闭包）<br>    Global（模块全局）全局作用域<br>    Built-in（内建）内建作用域</p>
<p>【规则】<br>    1、静态作用域规则<br>         定义：python中变量的作用域是由它在源代码中的位置决定的。（名字查找是动态发生的）<br>         说明：参考代码3/4，以代码3为例说明，在模块中定义了一个全局变量 i = 1，在test方法中执行 i += 1，对变量 i进行了赋值动作，该赋值动作决定了i在test()方法中是一个局部变量， i += 1可以拆分为两步执行，首先执行 i + 1, 然后将结果赋值给i。执行i + 1操作时，i虽然申明为局部变量，但是没有绑定任何具体值，因此报错。<br>    2、最内嵌套作用域规则<br>         定义：由一个赋值语句引进的名字在这个赋值语句所在的作用域里是可见（起作用）的，而且在其内部嵌套的每个作用域内也可见，除非它被嵌套于内部的且引进同样名字的赋值语句所遮蔽。<br>         说明：参考代码5. 方法g()是方法f()中定义的内嵌函数。在方法f()中定义的局部变量 i =2，在内嵌方法 g()中是可见的。如果在g()中又定义一个重名的变量 i = 3，则f()中定义的变量将被遮蔽。</p>
<h1 id="4、命名空间与作用域的关系"><a href="#4、命名空间与作用域的关系" class="headerlink" title="4、命名空间与作用域的关系"></a>4、命名空间与作用域的关系</h1><pre><code>命名空间定义了在某个作用域内变量名和绑定值之间的对应关系，命名空间是键值对的集合，变量名与值是一一对应关系。作用域定义了命名空间中的变量能够在多大范围内起作用。
命名空间在python解释器中是以字典的形式存在的，是以一种可以看得见摸得着的实体存在的。作用域是python解释器定义的一种规则，该规则确定了运行时变量查找的顺序，是一种形而上的虚的规定。</code></pre><p>【变量查找法则】<br>    python解释器动态执行过程中，对遇到的变量进行解释时，是按照一条固定的作用域链查找解释的，又称为LEGB法则。<br>    其中L代表Local 局部作用域，E代表Enclosing 嵌套作用域，G代表Global 全局作用域，B代表Built-in 内建作用域。<br>    python解释器查找变量时，会按照顺序依次查找局部作用域，嵌套作用域，全局作用域，内建作用域，在任意一个作用域中找到变量则停止查找，所有作用域查找完成没有找到对应的变量，则抛出 NameError: name ‘xxxx’ is not defined的异常。<br>    在局部作用域中，可以看到局部作用域、嵌套作用域、全局作用域、内建作用域中所有定义的变量。<br>    在全局作用域中，可以看到全局作用域、内建作用域中的所有定义的变量，无法看到局部作用域中的变量。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>git init                                                  # 初始化本地git仓库（创建新仓库）<br>git config –global user.name “xxx”                       # 配置用户名<br>git config –global user.email “<a href="mailto:xxx@xxx.com">xxx@xxx.com</a>“              # 配置邮件<br>git config –global color.ui true                         # git status等命令自动着色<br>git config –global color.status auto<br>git config –global color.diff auto<br>git config –global color.branch auto<br>git config –global color.interactive auto<br>git config –global –unset http.proxy                    # remove  proxy configuration on git<br>git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库<br>git status                                                # 查看当前版本状态（是否修改）<br>git add xyz                                               # 添加xyz文件至index<br>git add .                                                 # 增加当前子目录下所有更改过的文件至index<br>git commit -m ‘xxx’                                       # 提交<br>git commit –amend -m ‘xxx’                               # 合并上一次提交（用于反复修改）<br>git commit -am ‘xxx’                                      # 将add和commit合为一步<br>git rm xxx                                                # 删除index中的文件<br>git rm -r *                                               # 递归删除<br>git log                                                   # 显示提交日志<br>git log -1                                                # 显示1行日志 -n为n行<br>git log -5<br>git log –stat                                            # 显示提交日志及相关变动文件<br>git log -p -m<br>git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容<br>git show dfb02                                            # 可只用commitid的前几位<br>git show HEAD                                             # 显示HEAD提交日志<br>git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本<br>git tag                                                   # 显示已存在的tag<br>git tag -a v2.0 -m ‘xxx’                                  # 增加v2.0的tag<br>git show v2.0                                             # 显示v2.0的日志及详细内容<br>git log v2.0                                              # 显示v2.0的日志<br>git diff                                                  # 显示所有未添加至index的变更<br>git diff –cached                                         # 显示所有已添加index但还未commit的变更<br>git diff HEAD^                                            # 比较与上一个版本的差异<br>git diff HEAD – ./lib                                    # 比较与HEAD版本lib目录的差异<br>git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的<br>git diff origin/master..master –stat                     # 只显示差异的文件，不显示具体内容<br>git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）<br>git branch                                                # 显示本地分支<br>git branch –contains 50089                               # 显示包含提交50089的分支<br>git branch -a                                             # 显示所有分支<br>git branch -r                                             # 显示所有原创分支<br>git branch –merged                                       # 显示所有已合并到当前分支的分支<br>git branch –no-merged                                    # 显示所有未合并到当前分支的分支<br>git branch -m master master_copy                          # 本地分支改名<br>git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出<br>git checkout -b master master_copy                        # 上面的完整版<br>git checkout features/performance                         # 检出已存在的features/performance分支<br>git checkout –track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支<br>git checkout v2.0                                         # 检出版本v2.0<br>git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出<br>git checkout – README                                    # 检出head版本的README文件（可用于修改错误回退）<br>git merge origin/master                                   # 合并远程master分支至当前分支<br>git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改<br>git push origin master                                    # 将当前分支push到远程master分支<br>git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支<br>git push –tags                                           # 把所有tag推送到远程仓库<br>git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）<br>git fetch –prune                                         # 获取所有原创分支并清除服务器上已删掉的分支<br>git pull origin master                                    # 获取远程分支master并merge到当前分支<br>git mv README README2                                     # 重命名文件README为README2<br>git reset –hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）<br>git rebase<br>git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）<br>git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933<br>git ls-files                                              # 列出git index包含的文件<br>git show-branch                                           # 图示当前分支历史<br>git show-branch –all                                     # 图示所有分支历史<br>git whatchanged                                           # 显示提交历史对应的文件修改<br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818<br>git ls-tree HEAD                                          # 内部命令：显示某个git对象<br>git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH<br>git reflog                                                # 显示所有提交，包括孤立节点<br>git show HEAD@{5}<br>git show master@{yesterday}                               # 显示master分支昨天的状态<br>git log –pretty=format:’%h %s’ –graph                   # 图示提交日志<br>git show HEAD~3<br>git show -s –pretty=raw 2be7fcb476<br>git stash                                                 # 暂存当前修改，将所有至为HEAD状态<br>git stash list                                            # 查看所有暂存<br>git stash show -p stash@{0}                               # 参考第一次暂存<br>git stash apply stash@{0}                                 # 应用第一次暂存<br>git grep “delete from”                                    # 文件中搜索文本“delete from”<br>git grep -e ‘#define’ –and -e SORT_DIRENT<br>git gc<br>git fsck</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装openfiler</title>
    <url>/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85openfiler.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Openfiler是一个基于rPath Linux系统的免费ISCIS/NAS应用。它是一个基于浏览器的免费网络存储管理实用程序，可以在单一框架中提供基于文件的网络连接存储 (NAS) 和基于块的存储区域网 (SAN)。Openfiler 支持 CIFS、NFS、HTTP/DAV 和 FTP。Openfiler能把标准x86/64架构的系统变成一个强大的NAS、SAN存储和IP存储网关，为管理员提供一个强大的管理平台，并能能应付未来的存储需求。依赖如VMware，Virtual Iron和Xen服务器虚拟化技术，Openfiler也可部署为一个虚拟机实例。<br>Openfiler的主要性能和优点：<br>1.可靠性—Openfiler可以支持软件和硬件的RAID，能监测和预警，并且可以做卷的快照和快速恢复。<br>2. 高可用性–Openfiler支持主动或被动的高可用性集群、多路径存储（MPIO）、块级别的复制。<br>3.性能–及时更新的Linux内核支持最新的CPU、网络和存储硬件。<br>4.可伸缩性—文件系统可扩展性最高可超出60TB，并能使文件系统大小可以在线的增长。</p>
<h1 id="openfiler安装"><a href="#openfiler安装" class="headerlink" title="openfiler安装"></a>openfiler安装</h1><h3 id="下载openfiler镜像"><a href="#下载openfiler镜像" class="headerlink" title="下载openfiler镜像"></a>下载openfiler镜像</h3><p><a href="https://www.openfiler.com/community/download" target="_blank" rel="noopener">链接🔗</a></p>
<h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>新建虚拟机，选择自定义<br><img src="/images/2020/07/26/a62b9fba-1e6d-45a0-8671-0e67b4c95302.png" alt="image.png"><br>选择虚拟机兼容性<br><img src="/images/2020/07/26/b797defc-3b51-42db-afec-24f5aa0ed0ce.png" alt="image.png"><br>选择稍后安装操作系统<br><img src="/images/2020/07/26/415c3b94-bfce-4d22-ade7-fd5ea4bfc5e0.png" alt="image.png"><br>选择系统为Linux并且选择为Red Hat Enterprise Linux 5<br><img src="/images/2020/07/26/4c2e82dd-0611-4ea4-860b-757d659b1190.png" alt="image.png"><br>命名虚拟机并且选择安装位置<br><img src="/images/2020/07/26/5ad5a368-53b4-4b5b-b4b7-4b50c3d844dd.png" alt="image.png"><br>处理器配置<br><img src="/images/2020/07/26/f8e854f8-86c6-4599-a917-75d952329ebe.png" alt="image.png"><br>虚拟机内存设置<br><img src="/images/2020/07/26/9840952f-5648-4e62-9120-40bea1417d3f.png" alt="image.png"><br>设置网络类型，选择桥接<br><img src="/images/2020/07/26/f2adc548-24b1-42d9-8927-376f2546e97f.png" alt="image.png"><br>选择I/O控制器类型<br><img src="/images/2020/07/26/094c5a2c-d9fb-404d-8ff3-af63c4ff9144.png" alt="image.png"><br>选择磁盘类型<br><img src="/images/2020/07/26/642a542b-0a15-4b30-8b06-fad1d5bde637.png" alt="image.png"><br>选择磁盘<br><img src="/images/2020/07/26/3de87fb9-9b81-46d8-b4fd-ac67e66d216e.png" alt="image.png"><br>指定磁盘容量<br><img src="/images/2020/07/26/c6a484d9-bb58-458b-b9b7-a15d2b1a3712.png" alt="image.png"><br>指定磁盘文件<br><img src="/images/2020/07/26/cef87bbd-9d2c-47a4-bf28-781bc87fc884.png" alt="image.png"><br>选择挂载安装镜像<br><img src="/images/2020/07/26/18d40631-dd49-4623-8451-bb872ff55318.png" alt="image.png"><br>开启虚拟机，进入此界面按回车<br><img src="/images/2020/07/26/55b6cbdc-e504-4403-8a9e-1dc520edfdc8.png" alt="image.png"><br>点击下一步<br><img src="/images/2020/07/26/10e86c71-14df-4a3e-8bae-761f9bdc74d2.png" alt="image.png"><br>选择适当的键盘<br><img src="/images/2020/07/26/5d3fd7b9-412b-45b7-940f-9fd2c644c1a0.png" alt="image.png"><br>初始化磁盘，选择”Yes”<br><img src="/images/2020/07/26/237a10bb-7207-4967-a114-5e0b063ba327.png" alt="image.png"><br>创建分区，选择”Yes”<br><img src="/images/2020/07/26/8c00f7ed-fb02-4846-b64e-fc16067b517a.png" alt="image.png"><br>选择使用静态的IP地址<img src="/images/2020/07/26/c459e249-a7b9-4ccc-9ac2-ff6b259ace07.png" alt="image.png"><br>配置网关与DNS服务器地址，这一步使用内网地址的话感觉DNS服务器配置与否都行。所以此处有点多余2333🤣<img src="/images/2020/07/26/03d29a10-b29e-4c0c-a8c1-d6bf12e987b1.png" alt="image.png"><br>选择时区，选择上海<img src="/images/2020/07/26/5e3bbc04-8a6f-4acc-a78c-f3650b2c6049.png" alt="image.png"><br>设置root密码<img src="/images/2020/07/26/afaf7d1a-4123-481b-ac1b-d70e0963b1d3.png" alt="image.png"><br>点击“Next”进行安装<img src="/images/2020/07/26/55bb2d31-4bb6-4263-91ce-cdee2f7025ae.png" alt="image.png"><br><img src="/images/2020/07/26/cb1b0604-c779-4b92-9480-2ee312a80381.png" alt="image.png"><br>安装完成，选择“Reboot”重启系统<br><img src="/images/2020/07/26/6937af98-bdc9-4a0b-afb3-b0d17f850c2a.png" alt="image.png"></p>
<h1 id="配置openfiler-的iscsi目标服务器"><a href="#配置openfiler-的iscsi目标服务器" class="headerlink" title="配置openfiler 的iscsi目标服务器"></a>配置openfiler 的iscsi目标服务器</h1><h3 id="1-重启进入操作系统"><a href="#1-重启进入操作系统" class="headerlink" title="1.重启进入操作系统"></a>1.重启进入操作系统</h3><p><img src="/images/2020/07/26/bebf2e4c-2748-4772-8287-41af3a38150e.png" alt="image.png"></p>
<h3 id="2-添加3块scsi硬盘"><a href="#2-添加3块scsi硬盘" class="headerlink" title="2.添加3块scsi硬盘"></a>2.添加3块scsi硬盘</h3><p><img src="/images/2020/07/26/40c3ce31-49f3-4b55-adb7-766f62fc9795.png" alt="image.png"><br>然后输入init 6重启操作系统，重新扫描scsi硬盘。<br><img src="/images/2020/07/26/c68166db-8831-4ef5-8446-e3f265a76d4d.png" alt="image.png"></p>
<h3 id="3-登录web界面"><a href="#3-登录web界面" class="headerlink" title="3.登录web界面"></a>3.登录web界面</h3><p>登录地址就是启动时页面上显示的IP地址;用户名是：openfiler ， 密码是：password</p>
<p><img src="/images/2020/07/26/66c20d26-c33b-451e-bdcc-21b48c828aa0.png" alt="image.png"></p>
<h3 id="4-磁盘配置RAID5"><a href="#4-磁盘配置RAID5" class="headerlink" title="4.磁盘配置RAID5"></a>4.磁盘配置RAID5</h3><p>登录成功后界面如下所示</p>
<p><img src="/images/2020/07/26/1adbd07d-6252-41eb-979b-af762f37357c.png" alt="image.png"></p>
<p>选择”Volumes”选项<br><img src="/images/2020/07/26/12ae85bc-1445-40de-8cfb-9090dbb3c043.png" alt="image.png"></p>
<p>选择右测得菜单栏“Block Devices”<br><img src="/images/2020/07/26/cab73e38-b09a-4535-b188-2cdda3dbc5e2.png" alt="image.png"></p>
<p>点击刚添加的三块硬盘</p>
<p><img src="/images/2020/07/26/71055f79-a98a-469b-a6bc-35ee26a1f6a8.png" alt="image.png"></p>
<p>创建raid分区类型</p>
<p><img src="/images/2020/07/26/cd25519f-0a0c-4ff4-b11b-3cdde6cddcf0.png" alt="image.png"></p>
<p>选择右侧的“Software RAID”<br><img src="/images/2020/07/26/b2ba056a-f670-43e9-80ad-fe9fbdfda22a.png" alt="image.png"></p>
<p>选择创建RAID5分区，点击“Add array”<br><img src="/images/2020/07/26/2fa2225b-bab8-4a7c-bd7e-964a5af2198f.png" alt="image.png"></p>
<h3 id="5-创建逻辑卷"><a href="#5-创建逻辑卷" class="headerlink" title="5.创建逻辑卷"></a>5.创建逻辑卷</h3><p>使用刚才创建好的raid5分区创建逻辑卷，点击“Volume Groups”</p>
<p><img src="/images/2020/07/26/c65b447a-fae2-4b44-882a-f70dce3c252b.png" alt="image.png"></p>
<p>点击“create new physical volumes”，给卷组起一个名字叫“First”，选择物理卷“/dev/md0”</p>
<p><img src="/images/2020/07/26/f2f2650a-e477-4bd4-8c12-20383c1282c5.png" alt="image.png"></p>
<p>点击右侧的“Add volume”<br><img src="/images/2020/07/26/7d86236b-602b-4761-a460-ea91d5865a74.png" alt="image.png"></p>
<p>创建卷，卷的名字叫“One”，卷描述“hello world”当然可以填其他的，容量调整为最大，FileSystem / Volume type： 选择 block(iSCSI,FC,etc)<br><img src="/images/2020/07/26/b1eeef6a-9faf-4e0a-9e27-c3063443310f.png" alt="image.png"></p>
<h3 id="6-启动iscsi目标服务器"><a href="#6-启动iscsi目标服务器" class="headerlink" title="6.启动iscsi目标服务器"></a>6.启动iscsi目标服务器</h3><p><img src="/images/2020/07/26/94683742-b973-4263-88bb-c2add97827ad.png" alt="image.png"></p>
<h3 id="7-配置访问控制列表，iscsi目标服务器"><a href="#7-配置访问控制列表，iscsi目标服务器" class="headerlink" title="7.配置访问控制列表，iscsi目标服务器"></a>7.配置访问控制列表，iscsi目标服务器</h3><p>选择“System”</p>
<p><img src="/images/2020/07/26/328c6199-ba14-4620-a97a-b7ceccdb2609.png" alt="image.png"></p>
<p>选择允许访问的ip地址或一个网段，然后点击“update”<br><img src="/images/2020/07/26/0f569178-a59f-444f-bd4b-50b05ce7fb31.png" alt="image.png"></p>
<p>选择Volumes<br><img src="/images/2020/07/26/7154ab2e-d624-43b1-baef-a3b2d4aee943.png" alt="image.png"></p>
<p>选择右边的“iSCSI Targets”</p>
<p><img src="/images/2020/07/26/391c8d3b-c29f-47b7-9d27-78f892e3e90a.png" alt="image.png"></p>
<p>添加一个target IQN<br><img src="/images/2020/07/26/b6519eef-ab67-4777-a277-e4b2ce58d5f5.png" alt="image.png"></p>
<p>选择“LUN Mapping”，然后进行映射</p>
<p><img src="/images/2020/07/26/94c26dde-efae-48ca-98e9-4a142d30e0ee.png" alt="image.png"></p>
<p>选择“Network ACL”，“ACCESS”下面改成“Allow”，然后点击“update”</p>
<p><img src="/images/2020/07/26/d3607d29-a38f-4d18-9bea-752c674da007.png" alt="image.png"></p>
<p>连接iscsi测试<br>打开iscsi发起程序，连接iscsi目标服务器<br><img src="/images/2020/07/26/039c2696-eb04-4828-b835-fb2b3b54832d.png" alt="image.png"><br><img src="/images/2020/07/26/8a56f05d-2968-4fd2-add9-56345cabbaa8.png" alt="image.png"></p>
<p>查看Windows磁盘管理，发现已经正常连接<br><img src="/images/2020/07/26/818b688a-0259-4af6-af5f-71dfc751740b.png" alt="image.png"></p>
<p>新建一个分区</p>
<p><img src="/images/2020/07/26/7f3c9172-1196-40af-8c2d-bebf17336811.png" alt="image.png"></p>
<p>复制文件速度测试<br><img src="/images/2020/07/26/26b461b7-bf26-4ecf-a8fc-715e5a84a383.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个属于自己的音乐网站</title>
    <url>/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>搭建一个云音乐网站，有这些东西是必需的：<br>1：网站源码<br>2：服务器<br>3：域名<br>云音乐源码在这：<a href="https://www.lanzous.com/i5i1fwb" target="_blank" rel="noopener">https://www.lanzous.com/i5i1fwb</a><br>然后服务器我这里选择一个虚拟主机，有一些这种免费的空间可以使用，这里我选择的是美国的，因为我域名是在自己买的，没备案，所以选择了国外的一款虚拟机：<a href="http://idc.xfbk.top/" target="_blank" rel="noopener">http://idc.xfbk.top/</a><br>自行注册，然后选择免费的那个购买<br><img src="/images/2020/07/28/ae51774c-4f6e-4963-9b1a-b6e12f13034f.png" alt="image.png"><br>点击FTP/文件管理<br><img src="/images/2020/07/28/8c87728c-6f62-4bad-83b4-596f9719a27d.png" alt="image.png"><br>打开在线文件管理器，上传源码<br><img src="/images/2020/07/28/beffed99-6b1e-4831-9091-d145538da78b.png" alt="image.png"><br>解压文件到wwwroot目录下<br><img src="/images/2020/07/28/512bd85f-4234-4b0c-80fc-17eeaa981ffd.png" alt="image.png"><br>现在就是进行域名的绑定，没有域名的可以去阿里云腾讯云等等购买，购买需要一些认证啊什么的，会有点麻烦，购买的域名需要解析，主页搜索域名控制台，然后点解析，再点添加记录，如下图<br><img src="/images/2020/07/28/f490f8fb-5c01-4ad5-aed5-79759f3b45c7.png" alt="image.png"><br>或者使用这个去注册获取个二级域名<a href="http://dns.txizd.cn/，有域名的点击右侧基本功能—域名绑定" target="_blank" rel="noopener">http://dns.txizd.cn/，有域名的点击右侧基本功能—域名绑定</a><br><img src="/images/2020/07/28/cccfadb4-c107-450d-826b-3c375cdf8d6e.png" alt="image.png"><br>到了这一步，那很好，你已经完成了基本操作，现在可以输入你绑定的域名查看<br>自己完成的，可以点击查看：<a href="http://zcmusic.bylds.cn" target="_blank" rel="noopener">http://zcmusic.bylds.cn/</a><br><img src="/images/2020/07/28/21d03fdc-a835-4a25-8f98-d3e114c67e36.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础知识入门及常见命令</title>
    <url>/Linux-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>1,V8:192.168.40.10<br>V1:192.168.40.11<br>Linux ip:192.168.40.128<br>2,Linux 是一个操作系统, 与 windows 的区别:<br>Linux:图形化界面简单,性能很快,在企业中当做服务器来使用.<br>Windows:图形化界面很炫,性能相对差,大众用户.<br>windows 的服务器: windows2003,windows2008,windows2012<br>3,Linux 的作用:<br>当做服务器来使用<br>4,Linux 中目录结构: bin:存放二进制可执行文件 sbin: 存放二进制可执行文件,只有 root 才能访问 etc:存放系统配置文件 usr:用于存放共享的系统资源 home:存放用户文件的根目录 root:超级的用户目录 dev:用于存放设备文件 lib:存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt:mount 系统管理员安装临时文件的安装点 boot:存放用于系统引导时使用的各种文件 tmp:用于存放各种临时文件 var:用于存放运行时需要改变数据的文件(log 日志) 5,NetWork connection:<br>Host-only:本地跟远方的 Linux 通信需要用这个<br>NAT:多个 Linux 系统之间相互通信<br>6,使用 SecureCRT<br>Linux 命令:<br>ifconfig: 查看 ip service network restart:重启<br>命令分类:<br>内部命令:执行 shell 解析器的一部分,存放在 bash 目录,执行速度快,不需要创建子进程<br>cd:切换目录 change directory pwd:显示当前工作目录 print working directory help:帮助 </p>
<p>外部命令:独立于 Shell 解析器之外的文件程序,执行速度慢,一般存放在 bin/sbin/usr/sbin/此类目录,执行时创建子线程. ls:显示文件和目录列表 mkdir:创建目录 cp:复制文件或目录 </p>
<p>操作文件或目录的命令:<br>pwd touch:创建空文件<br>echo:写文件内容: echo “aaa”&gt;a.txt mkdir:创建目录<br>-p 父目录不存在的情况下先生成父目录<br>cp:复制文件或目录<br>-r:递归处理,将指定目录下的文件与子目录一并拷贝 mv:移动文件或目录,文件或目录改名 rm:删除文件<br>-r 同时删除该目录下的所有文件 -f 强制删除文件或目录<br>rmdir:删除空目录 cat:显示文本文件内容 more,less:分页显示文本文件内容 head,tail:查看文本中开头或结尾部分的内容. </p>
<p>查看帮助文档:<br>内部命令 :help+命令(help cd) 外部命令: man+命令(man ls) </p>
<p>7,常见命令<br>===========常用命令============= 一,目录与文件命令<br>1,目录处理命令:mkdir,rm,ls,find,cd,mv,cp,pwd,chmod<br>2,操作文件命令:touch,rm,find,cat,more,less<br>3,压缩/解压命令:gzip,bzip2,tar<br>4,其他常用命令:head,tail,wc,in,mount </p>
<p>二,用户操作命令<br>useradd,userdel,usermod<br>三,用户组操作命令<br>groupadd,groupdel,groupmod<br>四,安装软件命令<br>yum,rpm<br>五,网络命令<br>ping,ifconfig,netstat </p>
<p>===========================<br>echo “welcome to linux” &gt; a.txt: 往 a.txt 中写入字符 cat a.txt: 查看 a.txt 中的内容 ctrl+L: 清屏 ctrl + z: 退出(cat &gt; file 写入文件时使用这个键退出写入) vi 模式下: 编辑完成后点 esc ,然后 如果要保存退出输入:wq,不保存退出输入:q!<br>点击 esc, shift + z + z 退出并保存<br>============详解============<br>mkdir:创建目录 (touch a.txt :创建文件) mkdir dir : 创建名称叫做 dir 目录, 创建单个目录<br>mkdir dir1 dir2 : 创建多个目录,dir1, dir2 mkdir dir{3..10}: 创建 dir3 dir4…dir10 </p>
<p>cp:copy 复制<br>复制文件:<br>cp a.txt b.txt: 复制 a.txt 且复制后的文件名为 b.txt cp a.txt dir: 将 a.txt 拷贝到 dir 文件夹下<br>cp <em>.txt dir<br>cp ../</em>.txt ../dir2:将上一级目录下的所有 txt 文件拷贝到上一级目录的 dir2 文件夹下 cp ../file* . //拷贝到上一级目录下的所有 file 文件到当前目录 </p>
<p>复制目录:<br>cp -r dir1 dir2: 将 dir1 目录复制到 dir2 目录中 cp -r dir/* dir1/ : 将 dir 中的所有文件和目录复制到 dir1 目录中 </p>
<p>mv:目录移动(剪切) 移动文件:<br>mv file1 file2 //如果 file2 不存在,将 file1 重命名为 file2 mv file2 file1//将 file2 命名为 file1, 如果 file1 中有内容, 则覆盖 mv dir/* dir1//将 dir 中所有目录及文件移动到 dir1 目录中 </p>
<p>移动目录:<br>mv dir dir1//将 dir 目录移动到 dir1 目录中 mv dir2 dir3 dir1//将 dir2 和 dir3 移动到 dir1 中 </p>
<p>rm:remove 删除删除文件:<br>rm a.txt //删除 a.txt rm a.txt b.txt //同时删除 a.txt b.txt<br>rm <em>txt//删除所有扩展名为 txt 的文件 rm -rf dir1/</em> //强制删除 dir1 下所有文件和目录 </p>
<p>删除目录: rm -rf dir1// 删除 dir1 下的所有文件和目录, f 是强制删除, 不需要提示 </p>
<p>cd:切换目录 cd .. //跳转到上一级目录 cd ~ //跳转到根目录 cd /usr/local //跳转到 usr 下的 local 目录 </p>
<p>pwd:显示当前的目录 </p>
<p>touch:创建文件<br>语法:touch filename </p>
<p>touch myfile1//创建单个文件,文件名为 myfile1 touch myfile2 myfile3//同时创建两个文件 touch myfile{1..10}//创建多个文件 </p>
<p>cat<br>功能 1: 查询文件内容,查询全部文件内容(如果文件过大, 会卡死)<br>cat filename// 查看文件名 filename 的文件内容 </p>
<p>功能 2: 可以创建文件, 并且写入内容<br>cat &gt; myfile10 </p>
<p>功能 3:合并文件,合并内容<br>cat myfile1 myfile2 &gt; myfile10//将 myfile1 和 myfile2 中的内容合并到 myfile10 中, myfile10 中内<br>容被覆盖<br>more: 查看文件, 可以分页查看 +n 从第几行开始<br>-n 定义屏幕显示多少行 </p>
<p>more myfile//分页查看 myfile 文件 more +3 myfile//从第三行开始查看 myfile 文件 more -2 myfile//每页显示两行 more +/pattern myfile//从 myfile 中搜索 pattern, 结果显示在第三行 </p>
<p>less: 查看文件, 分页上下翻滚页 </p>
<p>head: 查看文件, 分页显示, 每页只显示 10 条 head myfile// 默认每页只显示 10 条 head -n 5 myfile//查看 myfile1,每页显示 5 条记录 head -c 12 myfile//查看 myfile,只显示前面 12 字节符 tail:查看文件, 实时监控文件 tail -f myfile// 实时监控 myfile 文件的变化<br>which:查找命令 which 命令<br>which mv//将 mv 命令的别名和 mv 所在的位置都给查询出来 </p>
<p>whereis: 查找命令 whereis mv: 查找命令的所在位置, 帮助文档,命令源码 </p>
<p>locate: 查找文件 locate myfile//搜索出来 myfile 所在目录, 需要先刷新 db, 使用命令: updatedb<br>新创建的文件搜索不到,新创建的文件被放在 Linux 的文件数据库, 需要属性文件数据库才能够找到 </p>
<p>find: 查找文件 find -name myfile//根据文件名, 在当前的目录进行查询 find -name “myfile”//和上面一个没有区别 find /etc/ /root/ -name “<em>[A-Z]</em>“ //查询目录 etc 和 root 下以 A-Z 开头的所有文件 find /etc/ /root/ -name “<em>[A-Z]</em>“ -exec ls -l {} ;// 把查询结果交给 ls 命令继续执行, 显示前面查询<br>结果详细信息.<br>-exec:执行,执行后面的命令,执行 ls -l 命令<br>{}: 标识查询结果在一行显示<br>; :命令要使用很好结束,斜杠是用来转义的. </p>
<p>| (管道命令)<br>把前面的查询结果交给后面的命令进行执行<br>ls -al | more -5 //查询所有,把查询的结果交给 more 命令去执行 </p>
<p>grep (过滤命令) 经常和管道命令一起使用<br>ps -ef | grep svn//查询所有进程, 过滤查询 svn </p>
<p>ln: 连接命令,创建快捷方式<br>ln -s myfile link//给 myfile 创建一个快捷方式 link </p>
<p>top:显示当前系统中消耗资源的进程情况 top //每隔 5 秒显示徐偶有进程的资源占用情况<br>top -d 2//每隔 2 秒刷新 </p>
<p>ps: 查看进程(常用) ps -ef//查看所有进程 ps -ef | grep redis //查看 redis 进程是否存在 </p>
<p>kill: 杀死进程(常用)<br>kill -9 PID<br>df: 显示磁盘使用情况 df -h//查看当前磁盘使用情况, 包括占用量单位 </p>
<p>shutdown: 关机 shutdown 系统关机 shutdown -r 关机后立即重启 shutdown -h 关机后不重新启动 </p>
<p>halt: 关机后关闭电源 </p>
<p>reboot: 重新启动 </p>
<p>=============================解压缩命令<br>gzip zip bzip2 压缩命令<br>gzip: 压缩文件, 不能够压缩目录<br>gzip file3// 把 file3 压缩, 压缩后文件名变为: file3.gz gunzip: 解压  gunzip file3.gz//解压单个文件 gunzip file1.gz file2.gz //解压多个文件<br>通常使用 gzip -d 来解压 gzip -dv file1.gz// 解压 file1, v 是视图可以看到解压过程 </p>
<p>bzip2 和 gzip 压缩方式一样 </p>
<p>zip:<br>zip myzip.zip file1 //将 file1 压缩成 myzip.zip unzip myzip.zip// 解压 </p>
<p>tar: 打包命令, 将多个文件压缩成一个文件<br>tar -cvf dir.tar dir//将 dir 目录下所有文件打包成 dir.tar<br>tar -xvf dir1.tar//解包 </p>
<p>gzip dir.tar //压缩 tar 文件变成 dir.tar.gz tar -zxvf dir.tar.gz//解压 dir.tar.gz 到 dir<br>-z:解压 gz 扩展名的文件<br>-x:解压 tar 包<br>-v:显示执行过程<br>-f:指定解压文件 </p>
<p>bzip2 dir.tar//使用 bzip2 压缩 tar 包: dir.tar.bz2<br>tar -jxvf dir.tar.bz2//解压 bzip2 格式包 </p>
<p>==============vim 文本编辑器 vim 进入编辑器 vi 有 3 总模式: 插入模式,命令模式,低行模式<br>1,插入模式 i 进入插入模式<br>2,命令模式 esc 进入命令模式<br>3,底行模式<br>:或者/ 进入底行模式<br>在命令模式下:<br>基本:<br>a:在当前光标位置的右边添加文本 i:在当前光标的位置的左边添加文本<br>A:在当前行的末尾位置添加文本<br>I:在当前行的开始处添加文本<br>O: 在当前行上面创建一行<br>0: 在当前行下面创建一行 R:替换(覆盖)当前光标位置及后面的若干文本<br>J:合并光标所在行及下一行为一行 </p>
<p>删除,撤销:<br>x:删除当前字符 nx: 删除从光标开始的 n 个字符 dd:删除当前行 ndd:删除 n 行 u:撤销上一步操作<br>U:撤销当前行的操作 </p>
<p>搜索:<br>/vpser: 向光标下搜索 vpser 字符串<br>?vpser: 向光标闪搜索 vpser 字符串 n: 先下搜索前一个搜索动作<br>N: 向上搜索前一个搜索动作 </p>
<p>跳转指定行:<br>n+: 向下跳转 n 行 n-: 向下跳转 n 行 nG: 调到行号为 n 的行<br>G: 跳至文件的底部 </p>
<p>设置行号:<br>:set nu //显示行号<br>:set noun//取消显示行号 </p>
<p>复制粘贴:<br>yy: 将当前行复制到缓存区 nyy:将当前行向下 n 行复制到缓存区 p: 当前行的下面进行粘贴 P: 当前光标所在行的上面进行粘贴 yw:复制光标到单词词尾 nyw:复制从光标开始的 n 个单词 y^: 复制从光标到行首的内容 y$: 复制从光标到行尾的内容 </p>
<p>替换:<br>:s/old/new //用 new 替换行中首次出现的 old 这个单词为 new<br>:s/old/new/g //用 new 替换当前行中所有的 old 单词<br>:n,m s/old/new/g //用 new 替换从 n 到 m 行在哪个所有的 old 单词<br>:%s/old/new/g //用 new 替换当前文件中的所有 old </p>
<p>8,权限管理<br>==================权限管理<br>-rwxrw-r– </p>
<ul>
<li>:类型<br>rwx:所属用户权限 rw-:所属组权限 r–:其他用户权限 </li>
</ul>
<p>最高位:文件类型<br>-: 普通文件 d: 目录 l: 快捷方式文件<br>高三位:u 所属用户权限(rwx) 中间三位:g 用户所属组权限(rw-) 第三位:o 其他用户权限(r–)<br>设置权限第一种方式举例:<br>———- file1: file1 无权限 (使用 chmod 0 file1 就取消所有权限) 设置权限: (x:执行权限 r:读权限 w:写权限)<br>chmod u+x file1—-&gt; —x—— file1 chmod u+r file1—-&gt; -r-x—— file1 chmod g+w file1—-&gt; -r-x-w—- file1 chmod g+rx file1—&gt; -r-xrwx— file1 chmod o+rwx file1–&gt; -r-xrwxrwx file1 </p>
<p>chomod o=x file1—&gt; -r-xrwx–x file1 </p>
<p>设置权限第二种方式举例: 用 421 来代表 rwx, 对应关系如下:<br>421 421 421 rwx rwx rwx<br>chmod 后面每一位数字匹配三位: 3=2(w)+1(x) 5=4(r)+1(x)<br>chmod 421 file1—–&gt; -r—w—x file1 (4 代表用户的读权限,2 代表组的写权限,1 代表其他用户的执行权限)<br>chmod 354 file1—–&gt; -rwxrwxw-x file1<br>9,安装软件<br>=======================安装软件 rpm: 安装麻烦 不建议使用 yum: 支持在线升级<br>1,关联 dvd 磁盘到本地: 右键 CentOS 选择 Settings, 然后找到 CD/DVD 选择 connected 即可. </p>
<p>2,Yum 命令支持在线升级,执行 yum 命令的时候,检测/etc/yum.repos.d/下面所有 repo 文件. repo 文件里面存储的是网址,yum 命令检测 repo 文件里面网址直接去网上下载. 可以把 repo 文件修改, 让 repo 文件指向本地的 dvd 盘.<br>3,挂载 dvd 盘到 mnt 目录<br>挂载命令:mount /dev/cdrom/ mnt/<br>挂载成功截图: </p>
<p>4,修改 repo 文件先备份 repo 文件: rename .repo .bak * //将所有 repo 扩展名的文件修改为后缀为.bak 创建自己的 repo 文件,指向本地文件:touch mine.repo 进入 vim 编辑 repo 文件: vim mine.repo<br>[centos6.6] name=centos-dvd<br>baseurl=file:///mnt gpgcheck=0 enabled=1 清空 yum 源:yum clean all 加载 yum 源:yum repolist all </p>
<p>安装 mysql: yum install mysql-server  </p>
<p>启动 mysql:service mysqld start </p>
<p>登录数据库:mysql -uroot p </p>
<p>查询数据库:show databases; </p>
<p>======================安装 jdk 和 tomcat<br>1, 先将 jdk 和 tomcat 传输到 Linux root 目录下 </p>
<p>2, 在 usr/local 下建立文件夹存放 jdk 和 tomcat 安装包: mkdir hadoop </p>
<p>3, 移动 root 目录下安装包 到 usr/local 目录下: mv jdk-7u55-linux-i586.tar.gz apache-tomcat7.0.47.tar.gz /usr/local/hadoop/ </p>
<p>4, 解压安装包: tar -zxvf jdk-7u55-linux-i586.tar.gz  tar -zxvf apache-tomcat-7.0.47.tar.gz 5,配置环境变量: vim profile 在最后一行添加: export JAVA_HOME=/usr/local/hadoop/jdk1.7.0_55 export PATH=$JAVA_HOME/bin:$PATH </p>
<p>6,刷新设置: source /etc/profile<br>7,查看是否安装成功:java -version </p>
<p>常见问题:<br>1,修复/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 问题<br>解决方案:在 64 系统里执行 32 位程序如果出现/lib/ld-linux.so.2:<br>bad ELF interpreter: No such file or directory，<br>安装下 glic 即可:sudo yum install glibc.i686<br>2,error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory 使用:sudo yum install zlib.i686  </p>
<p>====================安装 lrzsz(可以上传文件到指定目录)<br>1,安装:yum install lrzsz<br>2,安装后使用命令: cd /usr/local/hadoop/<br>rz: 直接弹出传输对话框<br>3,将 tomcat 传递到 hadoop 目录下<br>4,启动 tomcat<br>cd /usr/local/hadoop/apache-tomcat-7.0.47/bin/<br>./startup.sh </p>
]]></content>
  </entry>
  <entry>
    <title>Java输入输出</title>
    <url>/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。</p>
<p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()：</p>
<figure class="highlight plain"><figcaption><span>class Main &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(&quot;A,&quot;);</span><br><span class="line">        System.out.print(&quot;B,&quot;);</span><br><span class="line">        System.out.print(&quot;C.&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;END&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式化输出<br>Java还提供了格式化输出的功能。为什么要格式化输出？因为计算机表示的数据不一定适合人来阅读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d &#x3D; 12900000;</span><br><span class="line">        System.out.println(d); &#x2F;&#x2F; 1.29E7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d &#x3D; 3.1415926;</span><br><span class="line">        System.out.printf(&quot;%.2f\n&quot;, d); &#x2F;&#x2F; 显示两位小数3.14</span><br><span class="line">        System.out.printf(&quot;%.4f\n&quot;, d); &#x2F;&#x2F; 显示4位小数3.1416</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>格式化输出整数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化输出十六进制整数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化输出浮点数</td>
</tr>
<tr>
<td>%e</td>
<td>格式化输出科学计数法表示的浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
</tbody></table>
<p>注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。</p>
<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n &#x3D; 12345000;</span><br><span class="line">        System.out.printf(&quot;n&#x3D;%d, hex&#x3D;%08x&quot;, n, n); &#x2F;&#x2F; 注意，两个%占位符必须传入两个数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的格式化参数请参考JDK文档<a href="java.util.Formatter">java.util.Formatter</a></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>和输出相比，Java的输入就要复杂得多。</p>
<p>我们先看一个从控制台读取一个字符串和一个整数的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建Scanner对象</span><br><span class="line">        System.out.print(&quot;Input your name: &quot;); &#x2F;&#x2F; 打印提示</span><br><span class="line">        String name &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取一行输入并获取字符串</span><br><span class="line">        System.out.print(&quot;Input your age: &quot;); &#x2F;&#x2F; 打印提示</span><br><span class="line">        int age &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取一行输入并获取整数</span><br><span class="line">        System.out.printf(&quot;Hi, %s, you are %d\n&quot;, name, age); &#x2F;&#x2F; 格式化输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。</p>
<p>然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。</p>
<p>有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。</p>
<p>要测试输入，我们不能在线运行它，因为输入必须从命令行读取，因此，需要走编译、执行的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javac Main.java</span><br></pre></td></tr></table></figure>
<p>这个程序编译时如果有警告，可以暂时忽略它，在后面学习IO的时候再详细解释。编译成功后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java Main</span><br><span class="line">Input your name: Bob</span><br><span class="line">Input your age: 12</span><br><span class="line">Hi, Bob, you are 12</span><br></pre></td></tr></table></figure>
<p>根据提示分别输入一个字符串和整数后，我们得到了格式化的输出。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；</p>
<p>Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() / …</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>最全常用正则表达式大全</title>
    <url>/%E6%9C%80%E5%85%A8%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>一、校验数字的表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 数字：^[0-9]*$</span><br><span class="line"></span><br><span class="line">2. n位的数字：^\d&#123;n&#125;$</span><br><span class="line"></span><br><span class="line">3. 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line"></span><br><span class="line">4. m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"></span><br><span class="line">5. 零和非零开头的数字：^(0|[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"></span><br><span class="line">9. 有两位小数的正实数：[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line"></span><br><span class="line">10. 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br><span class="line"></span><br><span class="line">11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">12. 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</span><br><span class="line"></span><br><span class="line">13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span><br><span class="line"></span><br><span class="line">14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span><br><span class="line"></span><br><span class="line">15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span><br><span class="line"></span><br><span class="line">16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span><br><span class="line"></span><br><span class="line">17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br><span class="line"></span><br><span class="line">18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br><span class="line"></span><br><span class="line">19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">二、校验字符的表达式</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span><br><span class="line"></span><br><span class="line">2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span><br><span class="line"></span><br><span class="line">3. 长度为3-20的所有字符：^.&#123;3,20&#125;$</span><br><span class="line"></span><br><span class="line">4. 由26个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"></span><br><span class="line">5. 由26个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"></span><br><span class="line">6. 由26个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"></span><br><span class="line">7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span><br><span class="line"></span><br><span class="line">8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span><br><span class="line"></span><br><span class="line">9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span><br><span class="line"></span><br><span class="line">10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span><br><span class="line"></span><br><span class="line">11. 可以输入含有^%&amp;&#39;,;&#x3D;?$\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">其它：</span><br><span class="line"></span><br><span class="line">.*匹配除 \n 以外的任何字符。</span><br><span class="line"></span><br><span class="line">&#x2F;[\u4E00-\u9FA5]&#x2F; 汉字</span><br><span class="line"></span><br><span class="line">&#x2F;[\uFF00-\uFFFF]&#x2F; 全角符号</span><br><span class="line"></span><br><span class="line">&#x2F;[\u0000-\u00FF]&#x2F; 半角符号</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三、特殊需求表达式</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\s]* 或 ^http:&#x2F;&#x2F;([\w-]+\.)+[\w-]+(&#x2F;[\w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br><span class="line"></span><br><span class="line">4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line"></span><br><span class="line">5. 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span><br><span class="line"></span><br><span class="line">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span><br><span class="line"></span><br><span class="line">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span><br><span class="line"></span><br><span class="line">8. 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</span><br><span class="line"></span><br><span class="line">9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br><span class="line"></span><br><span class="line">10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line"></span><br><span class="line">11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$</span><br><span class="line"></span><br><span class="line">12. 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line">13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</span><br><span class="line"></span><br><span class="line">14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line"></span><br><span class="line">15. 钱的输入格式：</span><br><span class="line"></span><br><span class="line">16. 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$</span><br><span class="line"></span><br><span class="line">17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</span><br><span class="line"></span><br><span class="line">19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</span><br><span class="line"></span><br><span class="line">20. 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br><span class="line"></span><br><span class="line">21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line"></span><br><span class="line">24. 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line"></span><br><span class="line">25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</span><br><span class="line"></span><br><span class="line">26. 中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line"></span><br><span class="line">27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br><span class="line"></span><br><span class="line">28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line"></span><br><span class="line">29. HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\1&gt;|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line"></span><br><span class="line">30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line"></span><br><span class="line">31. 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br><span class="line"></span><br><span class="line">32. 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)</span><br><span class="line"></span><br><span class="line">33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span><br><span class="line"></span><br><span class="line">34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br><span class="line"></span><br><span class="line">35. IP-v4地址：\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b (提取IP地址时有用)</span><br><span class="line">36. 校验IP-v6地址:(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br><span class="line">37. 子网掩码：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</span><br><span class="line">38. 校验日期:^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。)</span><br><span class="line">39. 抽取注释：&lt;!--(.*?)--&gt;</span><br><span class="line">40. 查找CSS属性:^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</span><br><span class="line">41. 提取页面超链接:(&lt;a\\s*(?!.*\\brel&#x3D;)[^&gt;]*)(href&#x3D;&quot;https?:\\&#x2F;\\&#x2F;)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot; rel&#x3D;&quot;external nofollow&quot; ]+)&quot;((?!.*\\brel&#x3D;)[^&gt;]*)(?:[^&gt;]*)&gt;</span><br><span class="line">42. 提取网页图片:\\&lt; *[img][^\\\\&gt;]*[src] *&#x3D; *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)</span><br><span class="line">43. 提取网页颜色代码:^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</span><br><span class="line">44. 文件扩展名效验:^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\&#x2F;:*?&quot;&lt;&gt;|]+\\.txt(l)?$</span><br><span class="line">45. 判断IE版本：^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\&#x2F;[5-9]\\.0).*$</span><br></pre></td></tr></table></figure>
<p>::: hljs-center</p>
<p>表达式全集</p>
<p>:::<br>正则表达式有多种不同的风格。下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表：<br><img src="/images/2020/07/30/4b94a700-9b71-4da7-9f0d-a51964525447.png" alt="image.png"><br><img src="/images/2020/07/30/62562774-c2de-40c5-b08b-aa383afc7a61.png" alt="image.png"><br><img src="/images/2020/07/30/85516dd0-52c4-4941-b44f-3b1c943ac5e5.png" alt="image.png"><br>以下是以PHP的语法所写的示例</p>
<p>验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间</p>
<?php $str = 'a1234'; if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) { echo "驗證成功"; } else { echo "驗證失敗"; } ?><p><br>简易的台湾身份证字号验证</p>
<?php $str = 'a1234'; if (preg_match("/^\w[12]\d{8}$/", $str)) { echo "驗證成功"; } else { echo "驗證失敗"; } ?><p><br>以下示例是用 Perl 语言写的，与上面的示例功能相同</p>
<p>print $str = “a1234” =~ m:^[a-zA-Z0-9]{4,16}$: ? “COMFIRM” : “FAILED”;<br>print $str = “a1234” =~ m”^\w[12]\d{8}$” ? “COMFIRM” : “INVAILD”;<br>::: hljs-center</p>
<p>如何写出高效率的正则表达式</p>
<p>:::</p>
<p>如果纯粹是为了挑战自己的正则水平，用来实现一些特效（例如使用正则表达式计算质数、解线性方程），效率不是问题；如果所写的正则表达式只是为了满足一两次、几十次的运行，优化与否区别也不太大。但是，如果所写的正则表达式会百万次、千万次地运行，效率就是很大的问题了。我这里总结了几条提升正则表达式运行效率的经验（工作中学到的，看书学来的，自己的体会），贴在这里。如果您有其它的经验而这里没有提及，欢迎赐教。</p>
<p>为行文方便，先定义两个概念。</p>
<p>误匹配：指正则表达式所匹配的内容范围超出了所需要范围，有些文本明明不符合要求，但是被所写的正则式“击中了”。例如，如果使用\d{11}来匹配11位的手机号，\d{11}不单能匹配正确的手机号，它还会匹配98765432100这样的明显不是手机号的字符串。我们把这样的匹配称之为误匹配。</p>
<p>漏匹配：指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则没有将这种情况囊括在内。例如，使用\d{18}来匹配18位的身份证号码，就会漏掉结尾是字母X的情况。</p>
<p>写出一条正则表达式，既可能只出现误匹配（条件写得极宽松，其范围大于目标文本），也可能只出现漏匹配（只描述了目标文本中多种情况种的一种），还可能既有误匹配又有漏匹配。例如，使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com这样的字串（合法的域名中不含下划线，\w包含了下划线这种情况），又会漏掉ab-c.com这样的域名（合法域名中可以含中划线，但是\w不匹配中划线）。</p>
<p>精准的正则表达式意味着既无误匹配且无漏匹配。当然，现实中存在这样的情况：只能看到有限数量的文本，根据这些文本写规则，但是这些规则将会用到海量的文本中。这种情况下，尽可能地（如果不是完全地）消除误匹配以及漏匹配，并提升运行效率，就是我们的目标。本文所提出的经验，主要是针对这种情况。</p>
<p>掌握语法细节。正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_]；perl正则式不支持肯定逆序环视中使用可变的重复（variable repetition inside lookbehind，例如(?&lt;=.*)abc），但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视（Lookbehind,如(?&lt;=ab)c）都不支持，而perl和Python是支持的。《精通正则表达式》第3章《正则表达式的特性和流派概览》明确地列出了各大派系正则的异同，这篇文章也简要地列出了几种常用语言、工具中正则的比较。对于具体使用者而言，至少应该详细了解正在使用的那种工作语言里正则的语法细节。</p>
<p>先粗后精，先加后减。使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，再逐步在局步实现细节。仍举刚才的手机号的例子，先界定\d{11}，总不会错；再细化为1[358]\d{9}，就向前迈了一大步（至于第二位是不是3、5、8，这里无意深究，只举这样一个例子，说明逐步细化的过程）。这样做的目的是先消除漏匹配（刚开始先尽可能多地匹配，做加法），然后再一点一点地消除误匹配（做减法）。这样有先有后，在考虑时才不易出错，从而向“不误不漏”这个目标迈进。</p>
<p>留有余地。所能看到的文本sample是有限的，而待匹配检验的文本是海量的，暂时不可见的。对于这样的情况，在写正则表达式时要跳出所能见到的文本的圈子，开拓思路，作出“战略性前瞻”。例如，经常收到这样的垃圾短信：“发<em>票”、“发#漂”。如果要写规则屏蔽这样烦人的垃圾短信，不但要能写出可以匹配当前文本的正则表达式 发[</em>#](?:票|漂)，还要能够想到 发.(?:票|漂|飘)之类可能出现的“变种”。这在具体的领域或许会有针对性的规则，不多言。这样做的目的是消除漏匹配，延长正则表达式的生命周期。</p>
<p>明确。具体说来，就是谨慎用点号这样的元字符，尽可能不用星号和加号这样的任意量词。只要能确定范围的，例如\w，就不要用点号；只要能够预测重复次数的，就不要用任意量词。例如，写析取twitter消息的脚本，假设一条消息的xml正文部分结构是<span class=”msg”>…</span>且正文中无尖括号，那么<span class=”msg”>[^&lt;]{1,480}</span>这种写法的思路要好于<span class=”msg”>.*</span>，原因有二：一是使用[^&lt;]，它保证了文本的范围不会超出下一个小于号所在的位置；二是明确长度范围，{1,480}，其依据是一条twitter消息大致能的字符长度范围。当然，480这个长度是否正确还可推敲，但是这种思路是值得借鉴的。说得狠一点，“滥用点号、星号和加号是不环保、不负责任的做法”。</p>
<p>不要让稻草压死骆驼。每使用一个普通括号()而不是非捕获型括号(?:…)，就会保留一部分内存等着你再次访问。这样的正则表达式、无限次地运行次数，无异于一根根稻草的堆加，终于能将骆驼压死。养成合理使用(?:…)括号的习惯。</p>
<p>宁简勿繁。将一条复杂的正则表达式拆分为两条或多条简单的正则表达式，编程难度会降低，运行效率会提升。例如用来消除行首和行尾空白字符的正则表达式s/^\s+|\s+$//g;，其运行效率理论上要低于s/^\s+//g; s/\s+$//g; 。这个例子出自《精通正则表达式》第五章，书中对它的评论是“它几乎总是最快的，而且显然最容易理解”。既快又容易理解，何乐而不为？工作中我们还有其它的理由要将C==(A|B)这样的正则表达式拆为A和B两条表达式分别执行。例如，虽然A和B这两种情况只要有一种能够击中所需要的文本模式就会成功匹配，但是如果只要有一条子表达式（例如A）会产生误匹配，那么不论其它的子表达式（例如B）效率如何之高，范围如何精准，C的总体精准度也会因A而受到影响。</p>
<p>巧妙定位。有时候，我们需要匹配的the，是作为单词的the（两边有空格），而不是作为单词一部分的t-h-e的有序排列（例如together中的the）。在适当的时候用上^，$，\b等等定位锚点，能有效提升找到成功匹配、淘汰不成功匹配的效率。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>华为ENSP命令大全</title>
    <url>/%E5%8D%8E%E4%B8%BAENSP%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>一、 生成树STP</p>
<p>注：桥优先级取值越小，则优先级越高，通过配置优先级（开销值cost）可控制根桥选举。当根桥发生故障则会选举新的根桥，当故障恢复根桥重新选举。通过设置端口优先级会改变对端交换机的端口角色。当非根交换机根端口发生故障另外一个端口会自动变为根端口</p>
<p>1、        stp enable启用stp</p>
<p>2、        stp mode stp</p>
<p>3、        stp root primary配置为根桥</p>
<p>4、        stp root secondary 次要的（备份根桥）</p>
<p>5、        display stp brief 查看stp信息</p>
<p>6、        display stp interface命令查看端口的STP状态</p>
<p>7、        display stp查看根桥信息</p>
<p>8、        stp priority 8192设置优先级</p>
<p>9、        stp por priority 16修改端口优先级</p>
<p>10、    display stp interface GigabitEthernet 0/0/9查看端口信息，优先级等….</p>
<p>11、    stp port priority 32设置端口优先级</p>
<p>12、    display current-configuration查看主要配置</p>
<p>13、    stp cost 200000修改端口开销值</p>
<p>二、 生成树RSTP</p>
<p>注：连接用户终端的端口为边缘端口。边缘端口可以不通过RSTP计算直接由Discarding状态转变为Forwarding状态。</p>
<p>边缘端口直接与用户终端相连，正常情况下不会收到BPDU报文。但如果攻击者向交换机的边缘端口发送伪造的BPDU报文，交换机会自动将边缘端口设置为非边缘端口，并重新进行生成树计算，从而引起网络震荡。在交换机上配置BPDU保护功能，可以防止该类攻击。</p>
<p>在运行RSTP协议的网络中，交换机依靠不断接收来自上游设备的BPDU报文维持根端口和Alternate端口的状态。如果由于链路拥塞或者单向链路故障导致交换机收不到来自上游设备的BPDU报文，交换机会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而会引起网络环路。可以在交换机上配置环路保护功能，避免此种情况发生。</p>
<p>1、        stp mode rstp开启rstp</p>
<p>2、        display stp查看rstp的简要信息</p>
<p>3、        stp edged-port enable</p>
<p>4、        stp bpdu-protection开启边缘端口保护功能</p>
<p>5、        display stp brief查看stp端口信息</p>
<p>6、        stp loop-protection配置环路保护功能</p>
<p>三、 路由配置</p>
<p>注：当链路发生故障时链路将不能实现通信，如果配置了备份静态路由网络则不受影响。需要注意的是，如果链路完好时路由表中则不存在备份路由条目，只有当链路故障时路由表中才会出现备份路由。备份路由的优先级必须低于链路的优先级，否则则会降低效率。</p>
<p>1、        display ip interface brief查看接口配置</p>
<p>2、        display ip routing-table查看路由表</p>
<p>3、        ip route-static 10.0.23.0 24 10.0.13.3配置静态路由（目标地址/下一跳）</p>
<p>4、        ip route-static 10.0.3.0 24 10.0.12.1 preference 80备份静态路由并配置优先级为80</p>
<p>5、        ip route-static 0.0.0.0 0.0.0.0 10.0.23.2 preference 80配置缺省路由</p>
<p>四、 配置RIPv1 和RIPv2</p>
<p>1、        rip 1启动rip协议</p>
<p>2、        network 10.0.0.0将网段发布到rip协议中</p>
<p>3、        debugging rip 1开启RIP调测功能，注意只能在用户视图下执行debugging命令</p>
<p>4、        display debugging查看当前的调测信息（用户视图）</p>
<p>5、        terminal debugging开启debug信息在终端屏幕上显示的功能</p>
<p>6、        undo debugging rip <process-id> or undo debugging all关闭调测功</p>
<p>7、        （rip 1）version 2配置RIPv2 协议</p>
<p>五、 RIPv2 路由汇总和认证</p>
<p>1、        rip 1启动rip协议</p>
<p>2、        [Huawei-rip-1]version 2启动ripv2协议</p>
<p>3、        rip summary-address IPadd 255.255.0.0 地址汇总（在进接口配置，相邻路由器查看）</p>
<p>4、        rip authentication-mode simple Huawei 配置明文认证</p>
<p>5、        reset ip routing-table statistics protocol rip清除在密码错误之前学到的路由信息（用户模式下）</p>
<p>6、        rip authentication-mode md5 usual Huawei 开启MD5认证</p>
<p>六、 OSPF 单区域配置</p>
<p>1、        ospf 1 router-id 10.0.1.1配置router id进入ospf1</p>
<p>2、        area 0 划分区域</p>
<p>3、        network 10.0.1.0 0.0.0.255 通告</p>
<p>4、        display ospf peer 查看邻居状态</p>
<p>5、        display ospf peer brief 查看简要的邻居状态信息</p>
<p>6、        display ospf interface GigabitEthernet 0/0/0查看接口信息（hello、dead时间参数）</p>
<p>7、        ospf timer hello/dead 15进接口修改报文时间</p>
<p>8、        ip route-static 0.0.0.0 0.0.0.0 LoopBack 2 创建缺省路由</p>
<p>9、        default-route-advertise 把缺省路由发布到ospf内</p>
<p>10、    ospf dr-priority 100修改端口dr优先级（修改优先级控制dr/bdr的选举）</p>
]]></content>
      <tags>
        <tag>ensp</tag>
      </tags>
  </entry>
  <entry>
    <title>思科模拟器配置命令大全</title>
    <url>/%E6%80%9D%E7%A7%91%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><ol>
<li>计算机命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PCA login: root                                  ；使用root用户</span><br><span class="line"></span><br><span class="line">password: linux                                  ；口令是linux</span><br><span class="line"></span><br><span class="line"># shutdown -h now                               ；同init 0 关机</span><br><span class="line"></span><br><span class="line"># logout</span><br><span class="line"></span><br><span class="line"># login</span><br><span class="line"></span><br><span class="line"># ifconfig                                        ；显示IP地址</span><br><span class="line"></span><br><span class="line"># ifconfig eth0 &lt;ip address&gt; netmask &lt;netmask&gt;    ；设置IP地址</span><br><span class="line"></span><br><span class="line"># ifconfig eht0 &lt;ip address&gt; netmask &lt;netmask&gt; down ； 删除IP地址</span><br><span class="line"></span><br><span class="line"># route add 0.0.0.0 gw &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># route del 0.0.0.0 gw &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># route add default gw &lt;ip&gt;                      ；设置网关</span><br><span class="line"></span><br><span class="line"># route del default gw &lt;ip&gt;                      ；删除网关</span><br><span class="line"></span><br><span class="line"># route                                            ；显示网关</span><br><span class="line"></span><br><span class="line"># ping &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"># telnet &lt;ip&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 交换机支持的命令：</span><br><span class="line"></span><br><span class="line">交换机基本状态：</span><br><span class="line"></span><br><span class="line">switch:                                            ；交换机的ROM状态</span><br><span class="line"></span><br><span class="line">rommon&gt;                                            ；路由器的ROM状态</span><br><span class="line"></span><br><span class="line">hostname&gt;                                        ；用户模式</span><br><span class="line"></span><br><span class="line">hostname#                                        ；特权模式</span><br><span class="line"></span><br><span class="line">hostname(config)#                               ；全局配置模式</span><br><span class="line"></span><br><span class="line">hostname(config-if)#                                ；接口状态</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机口令设置：</span><br><span class="line"></span><br><span class="line">switch&gt;enable                                      ；进入特权模式</span><br><span class="line"></span><br><span class="line">switch#config terminal                            ；进入全局配置模式</span><br><span class="line"></span><br><span class="line">switch(config)#hostname &lt;hostname&gt;                ；设置交换机的主机名</span><br><span class="line"></span><br><span class="line">switch(config)#enable secret xxx                    ；设置特权加密口令</span><br><span class="line"></span><br><span class="line">switch(config)#enable password xxa                ；设置特权非密口令</span><br><span class="line"></span><br><span class="line">switch(config)#line console 0                   ；进入控制台口</span><br><span class="line"></span><br><span class="line">switch(config-line)#line vty 0 4                    ；进入虚拟终端</span><br><span class="line"></span><br><span class="line">switch(config-line)#login                          ；允许登录</span><br><span class="line"></span><br><span class="line">switch(config-line)#password xx                    ；设置登录口令xx</span><br><span class="line"></span><br><span class="line">switch#exit                                     ；返回命令</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机VLAN设置：</span><br><span class="line"></span><br><span class="line">switch#vlan database                                ；进入VLAN设置</span><br><span class="line"></span><br><span class="line">switch(vlan)#vlan 2                                ；建VLAN 2</span><br><span class="line"></span><br><span class="line">switch(vlan)#no vlan 2                            ；删vlan 2</span><br><span class="line"></span><br><span class="line">switch(config)#int f0&#x2F;1                         ；进入端口1</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport access vlan 2       ；当前端口加入vlan 2</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport mode trunk          ；设置为干线</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport trunk allowed vlan 1,2 ；设置允许的vlan</span><br><span class="line"></span><br><span class="line">switch(config-if)#switchport trunk encap dot1q    ；设置vlan 中继</span><br><span class="line"></span><br><span class="line">switch(config)#vtp domain &lt;name&gt;                    ；设置发vtp域名</span><br><span class="line"></span><br><span class="line">switch(config)#vtp password &lt;word&gt;                ；设置发vtp密码</span><br><span class="line"></span><br><span class="line">switch(config)#vtp mode server                   ；设置发vtp模式</span><br><span class="line"></span><br><span class="line">switch(config)#vtp mode client                   ；设置发vtp模式</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机设置IP地址：</span><br><span class="line"></span><br><span class="line">switch(config)#interface vlan 1                    ；进入vlan 1</span><br><span class="line"></span><br><span class="line">switch(config-if)#ip address &lt;IP&gt; &lt;mask&gt;          ；设置IP地址</span><br><span class="line"></span><br><span class="line">switch(config)#ip default-gateway &lt;IP&gt;              ；设置默认网关</span><br><span class="line"></span><br><span class="line">switch#dir flash:                               ；查看闪存</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">交换机显示命令：</span><br><span class="line"></span><br><span class="line">switch#write                                     ；保存配置信息</span><br><span class="line"></span><br><span class="line">switch#show vtp                                  ；查看vtp配置信息</span><br><span class="line"></span><br><span class="line">switch#show run                                  ；查看当前配置信息</span><br><span class="line"></span><br><span class="line">switch#show vlan                                  ；查看vlan配置信息</span><br><span class="line"></span><br><span class="line">switch#show interface                            ；查看端口信息</span><br><span class="line"></span><br><span class="line">switch#show int f0&#x2F;0                                ；查看指定端口信息</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3. 路由器支持的命令：</span><br><span class="line"></span><br><span class="line">路由器显示命令：</span><br><span class="line"></span><br><span class="line">router#show run                                  ；显示配置信息</span><br><span class="line"></span><br><span class="line">router#show interface                            ；显示接口信息</span><br><span class="line"></span><br><span class="line">router#show ip route                                ；显示路由信息</span><br><span class="line"></span><br><span class="line">router#show cdp nei                                ；显示邻居信息</span><br><span class="line"></span><br><span class="line">router#reload              　   　                ；重新起动</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器口令设置：</span><br><span class="line"></span><br><span class="line">router&gt;enable                                      ；进入特权模式</span><br><span class="line"></span><br><span class="line">router#config terminal                            ；进入全局配置模式</span><br><span class="line"></span><br><span class="line">router(config)#hostname &lt;hostname&gt;                ；设置交换机的主机名</span><br><span class="line"></span><br><span class="line">router(config)#enable secret xxx                    ；设置特权加密口令</span><br><span class="line"></span><br><span class="line">router(config)#enable password xxb                ；设置特权非密口令</span><br><span class="line"></span><br><span class="line">router(config)#line console 0                   ；进入控制台口</span><br><span class="line"></span><br><span class="line">router(config-line)#line vty 0 4                    ；进入虚拟终端</span><br><span class="line"></span><br><span class="line">router(config-line)#login                          ；要求口令验证</span><br><span class="line"></span><br><span class="line">router(config-line)#password xx                    ；设置登录口令xx</span><br><span class="line"></span><br><span class="line">router(config)#(Ctrl+z)                         ； 返回特权模式</span><br><span class="line"></span><br><span class="line">router#exit                                     ；返回命令</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器配置：</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0                         ；进入Serail接口</span><br><span class="line"></span><br><span class="line">router(config-if)#no shutdown                   ；激活当前接口</span><br><span class="line"></span><br><span class="line">router(config-if)#clock rate 64000                ；设置时钟频率</span><br><span class="line"></span><br><span class="line">router(config-if)#ip address &lt;ip&gt; &lt;netmask&gt;        ；设置IP地址</span><br><span class="line"></span><br><span class="line">router(config-if)#ip address &lt;ip&gt; &lt;netmask&gt; second   ；设置第二个IP</span><br><span class="line"></span><br><span class="line">router(config-if)#int f0&#x2F;0.1                      ；进入子接口</span><br><span class="line"></span><br><span class="line">router(config-subif.1)#ip address &lt;ip&gt; &lt;netmask&gt; ；设置子接口IP</span><br><span class="line"></span><br><span class="line">router(config-subif.1)#encapsulation dot1q &lt;n&gt;    ；绑定vlan中继协议</span><br><span class="line"></span><br><span class="line">router(config)#config-register 0x2142              ；跳过配置文件</span><br><span class="line"></span><br><span class="line">router(config)#config-register 0x2102              ；正常使用配置文件</span><br><span class="line"></span><br><span class="line">router#reload                                      ；重新引导</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器文件操作：</span><br><span class="line"></span><br><span class="line">router#copy running-config startup-config       ；保存配置</span><br><span class="line"></span><br><span class="line">router#copy running-config tftp                    ；保存配置到tftp</span><br><span class="line"></span><br><span class="line">router#copy startup-config tftp                    ；开机配置存到tftp</span><br><span class="line"></span><br><span class="line">router#copy tftp flash:                         ；下传文件到flash</span><br><span class="line"></span><br><span class="line">router#copy tftp startup-config                    ；下载配置文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ROM状态：</span><br><span class="line"></span><br><span class="line">Ctrl+Break                                        ；进入ROM监控状态</span><br><span class="line"></span><br><span class="line">rommon&gt;confreg 0x2142                            ；跳过配置文件</span><br><span class="line"></span><br><span class="line">rommon&gt;confreg 0x2102                            ；恢复配置文件</span><br><span class="line"></span><br><span class="line">rommon&gt;reset                                     ；重新引导</span><br><span class="line"></span><br><span class="line">rommon&gt;copy xmodem:&lt;sname&gt; flash:&lt;dname&gt;          ；从console传输文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">rommon&gt;IP_ADDRESS&#x3D;10.65.1.2                      ；设置路由器IP</span><br><span class="line"></span><br><span class="line">rommon&gt;IP_SUBNET_MASK&#x3D;255.255.0.0                ；设置路由器掩码</span><br><span class="line"></span><br><span class="line">rommon&gt;TFTP_SERVER&#x3D;10.65.1.1                      ；指定TFTP服务器IP</span><br><span class="line"></span><br><span class="line">rommon&gt;TFTP_FILE&#x3D;c2600.bin                          ；指定下载的文件</span><br><span class="line"></span><br><span class="line">rommon&gt;tftpdnld                                  ；从tftp下载</span><br><span class="line"></span><br><span class="line">rommon&gt;dir flash:                               ；查看闪存内容</span><br><span class="line"></span><br><span class="line">rommon&gt;boot                                     ；引导IOS</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">静态路由：</span><br><span class="line"></span><br><span class="line">ip route &lt;ip-address&gt; &lt;subnet-mask&gt; &lt;gateway&gt;    ；命令格式</span><br><span class="line"></span><br><span class="line">router(config)#ip route 2.0.0.0 255.0.0.0 1.1.1.2   ；静态路由举例</span><br><span class="line"></span><br><span class="line">router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2 ；默认路由举例</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">动态路由：</span><br><span class="line"></span><br><span class="line">router(config)#ip routing                          ；启动路由转发</span><br><span class="line"></span><br><span class="line">router(config)#router rip                          ；启动RIP路由协议。</span><br><span class="line"></span><br><span class="line">router(config-router)#network &lt;netid&gt;              ；设置发布路由</span><br><span class="line"></span><br><span class="line">router(config-router)#negihbor &lt;ip&gt;             ；点对点帧中继用。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">帧中继命令：</span><br><span class="line"></span><br><span class="line">router(config)#frame-relay switching             ；使能帧中继交换</span><br><span class="line"></span><br><span class="line">router(config-s0)#encapsulation frame-relay        ；使能帧中继</span><br><span class="line"></span><br><span class="line">router(config-s0)#fram-relay lmi-type cisco        ；设置管理类型</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay intf-type DCE        ；设置为DCE</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay dlci 16              ；</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay local-dlci 20        ；设置虚电路号</span><br><span class="line"></span><br><span class="line">router(config-s0)#frame-relay interface-dlci 16 ；</span><br><span class="line"></span><br><span class="line">router(config)#log-adjacency-changes             ；记录邻接变化</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0.1 point-to-point          ；设置子接口点对点</span><br><span class="line"></span><br><span class="line">router#show frame pvc                            ；显示永久虚电路</span><br><span class="line"></span><br><span class="line">router#show frame map                            ；显示映射</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">基本访问控制列表：</span><br><span class="line"></span><br><span class="line">router(config)#access-list &lt;number&gt; permit|deny &lt;source_ip&gt; &lt;wild|any&gt;</span><br><span class="line"></span><br><span class="line">router(config)#interface &lt;interface&gt;             ；default:deny any</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group &lt;number&gt; in|out   ；defaultut</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 1 deny host 10.65.1.1</span><br><span class="line"></span><br><span class="line">router(config)#access-list 1 permit any</span><br><span class="line"></span><br><span class="line">router(config)#int f0&#x2F;0</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例2：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit 10.8.1.1</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 deny 10.8.1.0 0.0.0.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit 10.8.0.0 0.0.255.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 deny 10.0.0.0 0.255.255.255</span><br><span class="line"></span><br><span class="line">router(config)#access-list 4 permit any</span><br><span class="line"></span><br><span class="line">router(config)#int f0&#x2F;1</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 4 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">扩展访问控制列表：</span><br><span class="line"></span><br><span class="line">access-list &lt;number&gt; permit|deny icmp &lt;S_IP wild&gt; &lt;D_IP wild&gt;[type]</span><br><span class="line"></span><br><span class="line">access-list &lt;number&gt; permit|deny tcp &lt;S_IP wild&gt; &lt;D_IP wild&gt;[port]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 101 deny icmp any 10.64.0.2 0.0.0.0 echo</span><br><span class="line"></span><br><span class="line">router(config)#access-list 101 permit ip any any</span><br><span class="line"></span><br><span class="line">router(config)#int s0&#x2F;0</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 101 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例2：</span><br><span class="line"></span><br><span class="line">router(config)#access-list 102 deny tcp any 10.65.0.2 0.0.0.0 eq 80</span><br><span class="line"></span><br><span class="line">router(config)#access-list 102 permit ip any any</span><br><span class="line"></span><br><span class="line">router(config)#interface s0&#x2F;1</span><br><span class="line"></span><br><span class="line">router(config-if)#ip access-group 102 out</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">删除访问控制例表:</span><br><span class="line"></span><br><span class="line">router(config)#no access-list 102</span><br><span class="line"></span><br><span class="line">router(config-if)#no ip access-group 101 in</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">路由器的nat配置</span><br><span class="line"></span><br><span class="line">Router(config-if)#ip nat inside              ；当前接口指定为内部接口</span><br><span class="line"></span><br><span class="line">Router(config-if)#ip nat outside              ；当前接口指定为外部接口</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static [p] &lt;私有IP&gt;&lt;公网IP&gt; [port]</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static 10.65.1.2 60.1.1.1</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source static tcp 10.65.1.3 80 60.1.1.1 80</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat pool p1 60.1.1.1 60.1.1.20 255.255.255.0</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source list 1 pool p1</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside destination list 2 pool p2</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat inside source list 2 interface s0&#x2F;0 overload</span><br><span class="line"></span><br><span class="line">Router(config)#ip nat pool p2 10.65.1.2 10.65.1.4 255.255.255.0 type rotary</span><br><span class="line"></span><br><span class="line">Router#show ip nat translation</span><br><span class="line"></span><br><span class="line">rotary 参数是轮流的意思，地址池中的IP轮流与NAT分配的地址匹配。</span><br><span class="line"></span><br><span class="line">overload参数用于PAT 将内部IP映射到一个公网IP不同的端口上。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">外部网关协议配置</span><br><span class="line"></span><br><span class="line">routerA(config)#router bgp 100</span><br><span class="line"></span><br><span class="line">routerA(config-router)#network 19.0.0.0</span><br><span class="line"></span><br><span class="line">routerA(config-router)#neighbor 8.1.1.2 remote-as 200</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">配置PPP验证：</span><br><span class="line"></span><br><span class="line">RouterA(config)#username &lt;RouterB&gt; password &lt;word&gt;</span><br><span class="line"></span><br><span class="line">RouterA(config)#int s0</span><br><span class="line"></span><br><span class="line">RouterA(config-if)#ppp authentication &#123;chap|pap&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4．PIX防火墙命令</span><br><span class="line"></span><br><span class="line">Pix525(config)#nameif ethernet0 outside security0    ；命名接口和级别</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet0 auto             ；设置接口方式</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet1 100full              ；设置接口方式</span><br><span class="line"></span><br><span class="line">Pix525(config)#interface ethernet1 100full shutdown</span><br><span class="line"></span><br><span class="line">Pix525(config)#ip address inside 192.168.0.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">Pix525(config)#ip address outside 133.0.0.1 255.255.255.252</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#global (if_name) natid ip-ip          ；定义公网IP区间</span><br><span class="line"></span><br><span class="line">Pix525(config)#global (outside) 1 7.0.0.1-7.0.0.15    ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#global (outside) 1 133.0.0.1          ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#no global (outside) 1 133.0.0.1       ；去掉设置</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (if_name) nat_id local_ip [netmark]</span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (inside) 1 0 0</span><br><span class="line"></span><br><span class="line">内网所有主机(0代表0.0.0.0)可以访问global 1指定的外网。</span><br><span class="line"></span><br><span class="line">Pix525(config)#nat (inside) 1 172.16.5.0 255.255.0.0</span><br><span class="line"></span><br><span class="line">内网172.16.5.0&#x2F;16网段的主机可以访问global 1指定的外网。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#route if_name 0 0 gateway_ip [metric]        ；命令格式</span><br><span class="line"></span><br><span class="line">Pix525(config)#route outside 0 0 133.0.0.1 1             ；例句</span><br><span class="line"></span><br><span class="line">Pix525(config)#route inside 10.1.0.0 255.255.0.0 10.8.0.1 1 ；例句</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#static (inside， outside) 133.0.0.1 192.168.0.8</span><br><span class="line"></span><br><span class="line">表示内部ip地址192.168.0.8，访问外部时被翻译成133.0.0.1全局地址。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Pix525(config)#static (dmz， outside) 133.0.0.1 172.16.0.8</span><br><span class="line"></span><br><span class="line">中间区域ip地址172.16.0.8，访问外部时被翻译成133.0.0.1全局地址。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1. switch配置命令</span><br><span class="line"></span><br><span class="line">(1)模式转换命令</span><br><span class="line"></span><br><span class="line">用户模式----特权模式,使用命令&quot;enable&quot;</span><br><span class="line"></span><br><span class="line">特权模式----全局配置模式,使用命令&quot;config t&quot;</span><br><span class="line"></span><br><span class="line">全局配置模式----接口模式,使用命令&quot;interface+接口类型+接口号&quot;</span><br><span class="line"></span><br><span class="line">全局配置模式----线控模式,使用命令&quot;line+接口类型+接口号&quot;</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line"></span><br><span class="line">用户模式:查看初始化的信息.</span><br><span class="line"></span><br><span class="line">特权模式:查看所有信息、调试、保存配置信息</span><br><span class="line"></span><br><span class="line">全局模式：配置所有信息、针对整个路由器或交换机的所有接口</span><br><span class="line"></span><br><span class="line">接口模式：针对某一个接口的配置</span><br><span class="line"></span><br><span class="line">线控模式：对路由器进行控制的接口配置</span><br><span class="line"></span><br><span class="line">（2）配置命令</span><br><span class="line"></span><br><span class="line">show running config 显示所有的配置</span><br><span class="line"></span><br><span class="line">show versin 显示版本号和寄存器值</span><br><span class="line"></span><br><span class="line">shut down 关闭接口</span><br><span class="line"></span><br><span class="line">no shutdown 打开接口</span><br><span class="line"></span><br><span class="line">ip add +ip地址 配置IP地址</span><br><span class="line"></span><br><span class="line">secondary+IP地址 为接口配置第二个IP地址</span><br><span class="line"></span><br><span class="line">show interface+接口类型+接口号 查看接口管理性</span><br><span class="line"></span><br><span class="line">show controllers interface 查看接口是否有DCE电缆</span><br><span class="line"></span><br><span class="line">show history 查看历史记录</span><br><span class="line"></span><br><span class="line">show terminal 查看终端记录大小</span><br><span class="line"></span><br><span class="line">hostname+主机名 配置路由器或交换机的标识</span><br><span class="line"></span><br><span class="line">config memory 修改保存在NVRAM中的启动配置</span><br><span class="line"></span><br><span class="line">exec timeout 0 0 设置控制台会话超时为0</span><br><span class="line"></span><br><span class="line">service password-encryptin 手工加密所有密码</span><br><span class="line"></span><br><span class="line">enable password +密码 配置明文密码</span><br><span class="line"></span><br><span class="line">ena sec +密码 配置密文密码</span><br><span class="line"></span><br><span class="line">line vty 0 4&#x2F;15 进入telnet接口</span><br><span class="line"></span><br><span class="line">password +密码 配置telnet密码</span><br><span class="line"></span><br><span class="line">line aux 0 进入AUX接口</span><br><span class="line"></span><br><span class="line">password +密码 配置密码</span><br><span class="line"></span><br><span class="line">line con 0 进入CON接口</span><br><span class="line"></span><br><span class="line">password +密码 配置密码</span><br><span class="line"></span><br><span class="line">bandwidth+数字 配置带宽</span><br><span class="line"></span><br><span class="line">no ip address 删除已配置的IP地址</span><br><span class="line"></span><br><span class="line">show startup config 查看NVRAM中的配置信息</span><br><span class="line"></span><br><span class="line">copy run-config startup config 保存信息到NVRAM</span><br><span class="line"></span><br><span class="line">write 保存信息到NVRAM</span><br><span class="line"></span><br><span class="line">erase startup-config 清除NVRAM中的配置信息</span><br><span class="line"></span><br><span class="line">show ip interface brief 查看接口的谪要信息</span><br><span class="line"></span><br><span class="line">banner motd # +信息 + # 配置路由器或交换机的描素信息</span><br><span class="line"></span><br><span class="line">description+信息 配置接口听描素信息</span><br><span class="line"></span><br><span class="line">vlan database 进入VLAN数据库模式</span><br><span class="line"></span><br><span class="line">vlan +vlan号+ 名称 创建VLAN</span><br><span class="line"></span><br><span class="line">switchport access vlan +vlan号 为VLAN为配接口</span><br><span class="line"></span><br><span class="line">interface vlan +vlan号 进入VLAN接口模式</span><br><span class="line"></span><br><span class="line">ip add +ip地址 为VLAN配置管理IP地址</span><br><span class="line"></span><br><span class="line">vtp+service&#x2F;tracsparent&#x2F;client 配置SW的VTP工作模式</span><br><span class="line"></span><br><span class="line">vtp +domain+域名 配置SW的VTP域名</span><br><span class="line"></span><br><span class="line">vtp +password +密码 配置SW的密码</span><br><span class="line"></span><br><span class="line">switchport mode trunk 启用中继</span><br><span class="line"></span><br><span class="line">no vlan +vlan号 删除VLAN</span><br><span class="line"></span><br><span class="line">show spamming-tree vlan +vlan号 查看VLA怕生成树议</span><br><span class="line"></span><br><span class="line">2. 路由器配置命令</span><br><span class="line"></span><br><span class="line">ip route+非直连网段+子网掩码+下一跳地址 配置静态&#x2F;默认路由</span><br><span class="line"></span><br><span class="line">show ip route 查看路由表</span><br><span class="line"></span><br><span class="line">show protocols 显示出所有的被动路由协议和接口上哪些协议被设置</span><br><span class="line"></span><br><span class="line">show ip protocols 显示了被配置在路由器上的路由选择协议,同时给出了在路由选择协议中使用</span><br><span class="line"></span><br><span class="line">的定时器</span><br><span class="line"></span><br><span class="line">                                   等信息</span><br><span class="line"></span><br><span class="line">router rip 激活RIP协议</span><br><span class="line"></span><br><span class="line">network +直连网段 发布直连网段</span><br><span class="line"></span><br><span class="line">interface lookback 0 激活逻辑接口</span><br><span class="line"></span><br><span class="line">passive-interface +接口类型+接口号 配置接口为被动模式</span><br><span class="line"></span><br><span class="line">debug ip +协议 动态查看路由更新信息</span><br><span class="line"></span><br><span class="line">undebug all 关闭所有DEBUG信息</span><br><span class="line"></span><br><span class="line">router eigrp +as号 激活EIGRP路由协议</span><br><span class="line"></span><br><span class="line">network +网段+子网掩码 发布直连网段</span><br><span class="line"></span><br><span class="line">show ip eigrp neighbors 查看邻居表</span><br><span class="line"></span><br><span class="line">show ip eigrp topology 查看拓扑表</span><br><span class="line"></span><br><span class="line">show ip eigrp traffic 查看发送包数量</span><br><span class="line"></span><br><span class="line">router ospf +process-ID 激活OSPF协议</span><br><span class="line"></span><br><span class="line">network+直连网段+area+区域号 发布直连网段</span><br><span class="line"></span><br><span class="line">show ip ospf 显示OSPF的进程号和ROUTER-ID</span><br><span class="line"></span><br><span class="line">encapsulation+封装格式 更改封装格式</span><br><span class="line"></span><br><span class="line">no ip admain-lookup 关闭路由器的域名查找</span><br><span class="line"></span><br><span class="line">ip routing 在三层交换机上启用路由功能</span><br><span class="line"></span><br><span class="line">show user 查看SW的在线用户</span><br><span class="line"></span><br><span class="line">clear line +线路号 清除线路</span><br><span class="line"></span><br><span class="line">3. 三层交换机配置命令</span><br><span class="line"></span><br><span class="line">配置一组二层端口</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">nterface range &#123;port-range&#125; 进入组配置状态</span><br><span class="line"></span><br><span class="line">配置三层端口</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface &#123;&#123;fastethernet | gigabitethernet&#125; interface-id&#125; | &#123;vlan vlan-id&#125; | &#123;port-</span><br><span class="line"></span><br><span class="line">channel port-channel-number&#125; 进入端口配置状态</span><br><span class="line"></span><br><span class="line">no switchport 把物理端口变成三层口</span><br><span class="line"></span><br><span class="line">ip address ip_address subnet_mask 配置IP地址和掩码</span><br><span class="line"></span><br><span class="line">no shutdown 激活端口</span><br><span class="line"></span><br><span class="line">     例：</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface gigabitethernet0&#x2F;2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# no switchport</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# ip address 192.20.135.21 255.255.255.0</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">配置VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">vlan vlan-id 输入一个VLAN号, 然后进入vlan配态，可以输入一个新的VLAN号或旧的来进行修改</span><br><span class="line"></span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">name vlan-name 可选)输入一个VLAN名，如果没有配置VLAN名，缺省的名字是VLAN号前面用0填满</span><br><span class="line"></span><br><span class="line">的4位数，如VLAN0004是VLAN4的缺省名字</span><br><span class="line"></span><br><span class="line">mtu mtu-size (可选) 改变MTU大小</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Switch(config)# vlan 20</span><br><span class="line"></span><br><span class="line">     Switch(config-vlan)# name test20</span><br><span class="line"></span><br><span class="line">     Switch(config-vlan)# end</span><br><span class="line"></span><br><span class="line">     或</span><br><span class="line"></span><br><span class="line">     Switch# vlan database</span><br><span class="line"></span><br><span class="line">     Switch(vlan)# vlan 20 name test20</span><br><span class="line"></span><br><span class="line">     Switch(vlan)# exit</span><br><span class="line"></span><br><span class="line">将端口分配给一个VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入要分配的端口</span><br><span class="line"></span><br><span class="line">switchport mode access 定义二层口</span><br><span class="line"></span><br><span class="line">switchport access vlan vlan-id 把端口分配给某一VLAN</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Enter configuration commands, one per line. End with CNTL&#x2F;Z.</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;1</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport mode access</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport access vlan 2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">     Switch#</span><br><span class="line"></span><br><span class="line">配置VLAN trunk</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-Id 进入端口配置状态</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置trunk封装ISL 或 802.1Q 或</span><br><span class="line"></span><br><span class="line">自动协商</span><br><span class="line"></span><br><span class="line">switchport mode &#123;dynamic &#123;auto | desirable&#125; | trunk&#125; 配置二层trunk模式。</span><br><span class="line"></span><br><span class="line">dynamic auto—自动协商是否成为trunk</span><br><span class="line"></span><br><span class="line">dynamic desirable—把端口设置为trunk如果对方端口是trunk, desirable, 配置Native VLAN</span><br><span class="line"></span><br><span class="line">（802.1q）</span><br><span class="line"></span><br><span class="line">或自动模式，trunk—设置端口为强制的trunk方式，而不理会对方端口是否为trunk</span><br><span class="line"></span><br><span class="line">switchport access vlan vlan-id 可选) 指定一个缺省VLAN, 如果此端口不再是trunk</span><br><span class="line"></span><br><span class="line">switchport trunk native vlan vlan-id 指定802.1Q native VLAN号</span><br><span class="line"></span><br><span class="line">     例：</span><br><span class="line"></span><br><span class="line">     Switch# configure terminal</span><br><span class="line"></span><br><span class="line">     Enter configuration commands, one per line. End with CNTL&#x2F;Z.</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;4</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport mode trunk</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport trunk encapsulation dot1q</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">定义TRUNK允许的VLAN</span><br><span class="line"></span><br><span class="line">configure terminal子 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入端口配置</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置二层口为trunk</span><br><span class="line"></span><br><span class="line">switchport trunk allowed vlan &#123;add | all | except | remove&#125; vlan-list可选) 配置trunk允</span><br><span class="line"></span><br><span class="line">许的VLAN.使用add, all, except, remove关健字</span><br><span class="line"></span><br><span class="line">no switchport trunk allowed vlan 允许所有VLAN通过</span><br><span class="line"></span><br><span class="line">     例</span><br><span class="line"></span><br><span class="line">     Switch(config)# interface fastethernet0&#x2F;1</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# switchport trunk allowed vlan remove 2</span><br><span class="line"></span><br><span class="line">     Switch(config-if)# end</span><br><span class="line"></span><br><span class="line">配置Native VLAN（802.1q）</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface interface-id 进入配置成802.1qtrunk的端口</span><br><span class="line"></span><br><span class="line">switchport trunk native vlan vlan-Id 配置native VLAN号</span><br><span class="line"></span><br><span class="line">no switchport trunk native vlan 端口配置命令回到缺省的状态</span><br><span class="line"></span><br><span class="line">配置基于端口权值的负载均衡</span><br><span class="line"></span><br><span class="line">configure terminal 进入Switch 1配置状态</span><br><span class="line"></span><br><span class="line">vtp domain domain-name 配置VTP域</span><br><span class="line"></span><br><span class="line">vtp mode server 将Switch 1配置成VTP server.</span><br><span class="line"></span><br><span class="line">show vtp status 验证VTP的配置</span><br><span class="line"></span><br><span class="line">show vlan 验证VLAN</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1端口</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置trunk封装</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置成trunk</span><br><span class="line"></span><br><span class="line">show interfaces fastethernet0&#x2F;1 switchport 验证VLAN配置</span><br><span class="line"></span><br><span class="line">按以上步骤对想要负载均衡的接口进行配置</span><br><span class="line"></span><br><span class="line">在另一个交换机上进行此配置</span><br><span class="line"></span><br><span class="line">show vlan 当trunk已经起来，在switch2上验证已经学到相的vlan配置</span><br><span class="line"></span><br><span class="line">configure terminal 在Switch 1上进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet0&#x2F;1 进入要配置的端口</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 8 port-priority 10 将端口权值10赋与VLAN 8.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 9 port-priority 10 将端口权值10赋与VLAN 9.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 10 port-priority 10 将端口权值10赋与VLAN 10.</span><br><span class="line"></span><br><span class="line">interface fastethernet0&#x2F;2 进入F0&#x2F;2</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 3 port-priority 10 将端口权值10赋与VLAN 3.</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 4 port-priority 10 将端口权值10赋与VLAN 4</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 5 port-priority 10 将端口权值10赋与VLAN 5</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 6 port-priority 10 将端口权值10赋与VLAN 10</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">copy running-config startup-config 保存配置</span><br><span class="line"></span><br><span class="line">配置STP路径值的负载均衡</span><br><span class="line"></span><br><span class="line">Trunk1走VLAN8－10，Trunk2走VLAN2－4</span><br><span class="line"></span><br><span class="line">configure terminal 进入 Switch 1配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1</span><br><span class="line"></span><br><span class="line">switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;配置封装</span><br><span class="line"></span><br><span class="line">switchport mode trunk 配置Trunk,缺省是ISL封装</span><br><span class="line"></span><br><span class="line">exit 退回</span><br><span class="line"></span><br><span class="line">在F0&#x2F;2口上重复2－4步骤</span><br><span class="line"></span><br><span class="line">exit 退回</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">show vlan验证switch1 已经学到Vlan</span><br><span class="line"></span><br><span class="line">configure terminal 进入配置状态</span><br><span class="line"></span><br><span class="line">interface fastethernet 0&#x2F;1 进入F0&#x2F;1</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 2 cost 30 设置Vlan2生成树路径值为30</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 3 cost 30 设置Vlan3生成树路径值为30</span><br><span class="line"></span><br><span class="line">spanning-tree vlan 4 cost 30 设置Vlan4生成树路径值为30</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">在switch1的F0&#x2F;2上重复9－11步骤设置VLAN8,9，10生成树路径值为30</span><br><span class="line"></span><br><span class="line">end 退出</span><br><span class="line"></span><br><span class="line">show running-config 验证配置</span><br><span class="line"></span><br><span class="line">copy running-config startup-config 保存配置</span><br><span class="line"></span><br><span class="line">补充:CISCO命令集——路由选择协议及排障</span><br><span class="line"></span><br><span class="line">     *ip route命令</span><br><span class="line"></span><br><span class="line">Router(config)# ip route &lt;目录网络或子网号&gt; [子网掩码] &lt;下一路由器IP地址 | 从本地出口</span><br><span class="line"></span><br><span class="line">的地址&gt; [管理距离0~255，默认为1]</span><br><span class="line"></span><br><span class="line">     （注：静态地址配置）</span><br><span class="line"></span><br><span class="line">     *ip default-network命令</span><br><span class="line"></span><br><span class="line">Router(config)# ip default-network &lt;目标网络号&gt;</span><br><span class="line"></span><br><span class="line">     (注：配合路由协使用，用其中的一个动态路由号作默认路由配置)</span><br><span class="line"></span><br><span class="line">Router(config)# ip route 0.0.0.0 0.0.0.0 &lt;下一路由器IP地址 | 从本地出口的地址&gt;</span><br><span class="line"></span><br><span class="line">     (注：只有一个公网地址时，在出口路由器上的配置)</span><br><span class="line"></span><br><span class="line">     *内部路由选择协议</span><br><span class="line"></span><br><span class="line">     *使用router和network命令</span><br><span class="line"></span><br><span class="line">Router(config)# router &lt;路由协议rip | igrp | eigrp | ospf | is-is等&gt; [自主系统号]</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用此路由协议的网络号&gt;</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用此路由协议的网络号&gt;</span><br><span class="line"></span><br><span class="line">     *路由信息协议RIP</span><br><span class="line"></span><br><span class="line">Router(config)# router rip</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用rip协议的有类别网络号&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip protocols</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# debug ip rip</span><br><span class="line"></span><br><span class="line">     *内部网关路由协议IGRP</span><br><span class="line"></span><br><span class="line">Router(config)# router igrp &lt;自主系统号&gt;</span><br><span class="line"></span><br><span class="line">Router(config-router)# network &lt;直接相连的要用igrp协议的有类别网络号&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip interface</span><br><span class="line"></span><br><span class="line">Router# show ip protocols</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# debug ip rip</span><br><span class="line"></span><br><span class="line">     *排除网络故障</span><br><span class="line"></span><br><span class="line">     排除网络故障的一个总体模型</span><br><span class="line"></span><br><span class="line">Router# ping &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line"></span><br><span class="line">Router# show interface &lt;有故障的接口&gt;</span><br><span class="line"></span><br><span class="line">Router# show run</span><br><span class="line"></span><br><span class="line">     *IP的故故障排除</span><br><span class="line"></span><br><span class="line">     检查可用的路由</span><br><span class="line"></span><br><span class="line">Router# show ip route &lt;有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">27.4.4 跟踪路由(Tracing the Route)</span><br><span class="line"></span><br><span class="line">SUN-A&gt; traceroute &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; winipcfg</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; ipconfig</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; ipconfig &#x2F; all</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; tracert &lt;有故障的主机 | 有故障的IP地址&gt;</span><br><span class="line"></span><br><span class="line">     使用扩展的ping来跟踪连接性</span><br><span class="line"></span><br><span class="line">Router# ping</span><br><span class="line"></span><br><span class="line">     *其它可能的故障</span><br><span class="line"></span><br><span class="line">     一个地址解析（ARP）的故障</span><br><span class="line"></span><br><span class="line">Router# show arp</span><br><span class="line"></span><br><span class="line">Router# show interface &lt;有故障的接口&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; arp -a</span><br><span class="line"></span><br><span class="line">SUN-A&gt; arp –a</span><br><span class="line"></span><br><span class="line">     验证终端系统的路由表</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; netstat –rn</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route –f add 0.0.0.0 mask 0.0.0.0 &lt;需要添加入的网关地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route [–f ] [[print | add | delete | change] [destination] [mask</span><br><span class="line"></span><br><span class="line">netmask] [gateway]]</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route add mask &lt;网络掩码&gt; &lt;网关ip地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; route delete mask &lt;网络掩码&gt; &lt;网关ip地址&gt;</span><br><span class="line"></span><br><span class="line">C:\windows\&gt; nbtstat &lt;相应的参数&gt;</span><br><span class="line"></span><br><span class="line">SUN-A&gt; netstat -rn路由器</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>思科</tag>
      </tags>
  </entry>
  <entry>
    <title>python的一些常用操作</title>
    <url>/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="连接-mongodb-数据库方法："><a href="#连接-mongodb-数据库方法：" class="headerlink" title="连接 mongodb 数据库方法："></a>连接 mongodb 数据库方法：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line">client &#x3D; MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">client.database(用户名对应的数据库名称).authenticate(&quot;user&quot;,&quot;password&quot;)</span><br><span class="line">print(&#39;连接数据库成功&#39;)</span><br><span class="line">users &#x3D; client.oneDB.users(client.数据库.表名)</span><br></pre></td></tr></table></figure>
<h1 id="数据库操-pip"><a href="#数据库操-pip" class="headerlink" title="数据库操 pip"></a>数据库操 pip</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义json对象</span><br><span class="line">post &#x3D; &#123;</span><br><span class="line">        &quot;name&quot;: name,</span><br><span class="line">        &quot;hex&quot;: hex,</span><br><span class="line">        &quot;style&quot;: style</span><br><span class="line">    &#125;</span><br><span class="line"># 使用数据库操作命令操作表</span><br><span class="line">users.insert_one(post)</span><br></pre></td></tr></table></figure>
<h1 id="打印数据库中存储字段方法："><a href="#打印数据库中存储字段方法：" class="headerlink" title="打印数据库中存储字段方法："></a>打印数据库中存储字段方法：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pprint</span><br><span class="line">for user in users.find():</span><br><span class="line">pprint.pprint(user)</span><br></pre></td></tr></table></figure>
<p>抓取网页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;html-color-codes.info&#x2F;color-names&#x2F;&quot;</span><br><span class="line">hdrs &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (X11; Fedora; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko)&#39;&#125;</span><br><span class="line">r &#x3D; requests.get(url, headers&#x3D;hdrs)</span><br><span class="line">soup &#x3D; BeautifulSoup(r.content)</span><br></pre></td></tr></table></figure>
<h1 id="通过-class-名获取标签的方法："><a href="#通过-class-名获取标签的方法：" class="headerlink" title="通过 class 名获取标签的方法："></a>通过 class 名获取标签的方法：</h1><ol>
<li>如果获取的结果是数组(tds=[])，需要先转换成字符串 string = ‘’.join(str(i) for i in tds)</li>
<li>通过方法 soup=BeautifulSoup(string)</li>
<li>soup.find_all(attrs={‘class’,’demo’})即可找到所有 class 名为 demo 的标签</li>
</ol>
<h1 id="flask-写后台接口："><a href="#flask-写后台接口：" class="headerlink" title="flask 写后台接口："></a>flask 写后台接口：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"># mongo.py</span><br><span class="line">from flask import Flask,abort</span><br><span class="line">from flask import jsonify</span><br><span class="line">from flask import request</span><br><span class="line"># from flask_pymongo import PyMongo</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">client &#x3D; MongoClient(&quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;&quot;)</span><br><span class="line">client.myblog.authenticate(&quot;user&quot;,&quot;password&quot;)</span><br><span class="line">database &#x3D; client[&quot;myblog&quot;]</span><br><span class="line">collection &#x3D; database[&quot;article&quot;]</span><br><span class="line"></span><br><span class="line">query &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line"># app.config[&#39;MONGO_DBNAME&#39;] &#x3D; &#39;myblog&#39;</span><br><span class="line"># app.config[&#39;MONGO_URI&#39;] &#x3D; &#39;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;myblog&#39;  </span><br><span class="line"># 如果部署在本上，其中ip地址可填127.0.0.1</span><br><span class="line">#</span><br><span class="line"># mongo &#x3D; PyMongo(app)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">def get_all_users():</span><br><span class="line">    star &#x3D; collection.find(query)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in star:</span><br><span class="line">        output.append(&#123;&#39;name&#39; : s[&#39;name&#39;]&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39; : output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;register&#39;, methods&#x3D;[&#39;POST&#39;])</span><br><span class="line">def add_user():</span><br><span class="line">    star &#x3D; mongo.db.userInfo</span><br><span class="line">    name &#x3D; request.json[&#39;name&#39;]</span><br><span class="line">    pwd &#x3D; request.json[&#39;pwd&#39;]</span><br><span class="line">    star_id &#x3D; star.insert(&#123;&#39;name&#39;: name, &#39;pwd&#39;: pwd&#125;)</span><br><span class="line">    new_star &#x3D; star.find_one(&#123;&#39;_id&#39;: star_id &#125;)</span><br><span class="line">    output &#x3D; &#123;&#39;name&#39; : new_star[&#39;name&#39;], &#39;pwd&#39; : new_star[&#39;pwd&#39;]&#125;</span><br><span class="line">    return jsonify(&#123;&#39;result&#39; : output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;modify&#x2F;&lt;string:name&gt;&#39;, methods&#x3D;[&#39;PUT&#39;])</span><br><span class="line">def update_user(name):</span><br><span class="line">    user &#x3D; mongo.db.userInfo.find(&#123;&quot;name&quot;:name&#125;)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in user:</span><br><span class="line">        output.append(&#123;&#39;name&#39;: s[&#39;name&#39;], &#39;pwd&#39;: s[&#39;pwd&#39;]&#125;)</span><br><span class="line">    if len(output) &#x3D;&#x3D; 0:</span><br><span class="line">        abort(404)</span><br><span class="line">    mongo.db.userInfo.update(&#123;&quot;name&quot;:name&#125;,&#123;&#39;$set&#39;:&#123;&quot;name&quot;:&quot;LZ111&quot;&#125;&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39;: output&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;delete&#x2F;&lt;string:name&gt;&#39;, methods&#x3D;[&#39;DELETE&#39;])</span><br><span class="line">def delete_user(name):</span><br><span class="line">    user &#x3D; mongo.db.userInfo.find(&#123;&quot;name&quot;: name&#125;)</span><br><span class="line">    output &#x3D; []</span><br><span class="line">    for s in user:</span><br><span class="line">        output.append(&#123;&#39;name&#39;: s[&#39;name&#39;], &#39;pwd&#39;: s[&#39;pwd&#39;]&#125;)</span><br><span class="line">    if len(output) &#x3D;&#x3D; 0:</span><br><span class="line">        abort(404)</span><br><span class="line">    mongo.db.userInfo.remove(&#123;&#39;name&#39;: name&#125;)</span><br><span class="line">    return jsonify(&#123;&#39;result&#39;: True&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # app.run(host &#x3D; &#39;0.0.0.0&#39;, port &#x3D; 80, debug &#x3D; True)</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql_front连接报错，sql执行错误#3167的解决方案</title>
    <url>/mysql-front%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%EF%BC%8Csql%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF-3167%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><p>在使用myql_front连接mysql时出现了:The ‘INFORMATION_SCHEMA.SESSION_VARIABLES’ feature is disabled; see the documentation for ‘show_compatibility_56’<br><img src="/images/2020/08/02/c26c91e6-cbff-4b10-a5b7-98edbe907f4e.png" alt="image.png"><br>百度后得知-从mysql5.7.6开始information_schema.global_status已经开始被舍弃，为了兼容性，此时需要打开 show_compatibility_56</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.global_status limit 3;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/e2d686c1-ae6e-4d06-9268-e64a632c21de.png" alt="image.png"><br>查看一下show_compatibility_56的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%show_compatibility_56%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/5be22427-fcce-40de-bcaa-9bfa86d0bffb.png" alt="image.png"><br>把show_compatibility_56打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global show_compatibility_56&#x3D;on;</span><br><span class="line">show variables like &#39;%show_compatibility_56%&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/eeb4b7be-0fbc-46da-a8d0-f1519b91a2a8.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.global_status limit 3;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/abc7d072-69be-466f-8452-50eabc00c7e6.png" alt="image.png"><br>然后即可使用mysql_front连接到mysql数据库了<br><img src="/images/2020/08/02/967f9772-4350-4768-84d2-0dcdb044d757.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>猫眼电影top100爬取</title>
    <url>/%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import re</span><br><span class="line">import urllib.request,urllib.error</span><br><span class="line">import xlwt</span><br><span class="line">import sqlite3</span><br><span class="line">def main():</span><br><span class="line">    baseurl &#x3D; &quot;https:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;4?offset&#x3D;&quot;</span><br><span class="line">    datalist &#x3D; getData(baseurl)</span><br><span class="line">    savepath &#x3D; &quot;.\\猫眼电影Top100.xls&quot;</span><br><span class="line">    saveData(datalist,savepath)</span><br><span class="line">findName &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;name&quot;&gt;(.*)&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">finfStar &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;star&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;,re.S)</span><br><span class="line">findRating &#x3D; re.compile(r&#39;&lt;p class&#x3D;&quot;score&quot;&gt;&lt;i class&#x3D;&quot;integer&quot;&gt;(.*)&lt;&#x2F;i&gt;&lt;i class&#x3D;&quot;fraction&quot;&gt;(.*)&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;&#39;)</span><br><span class="line">def getData(baseurl):</span><br><span class="line">    datalist &#x3D; []</span><br><span class="line">    for i in range(0,10):</span><br><span class="line">        url &#x3D; baseurl + str(i*10)</span><br><span class="line">        html &#x3D; askURL(url)</span><br><span class="line">        soup &#x3D; BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup.find_all(&#39;div&#39;,class_&#x3D;&quot;board-item-main&quot;):</span><br><span class="line">            data &#x3D; []</span><br><span class="line">            item &#x3D; str(item)</span><br><span class="line">            names &#x3D; re.findall(findName,item)[0]</span><br><span class="line">            data.append(names)</span><br><span class="line">            rating &#x3D; re.findall(findRating,item)[0]</span><br><span class="line">            data.append(rating)</span><br><span class="line">            star &#x3D; re.findall(finfStar,item)</span><br><span class="line">            if len(star) !&#x3D; 0:</span><br><span class="line">                inq &#x3D; star[0].replace(&quot;。&quot;,&quot;&quot;)</span><br><span class="line">                data.append(star)</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot; &quot;)</span><br><span class="line">            datalist.append(data)</span><br><span class="line">    return datalist</span><br><span class="line">def askURL(url):</span><br><span class="line">    head &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.81 Safari&#x2F;537.36 SE 2.X MetaSr 1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; urllib.request.Request(url,headers &#x3D; head)</span><br><span class="line">    html &#x3D; &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; urllib.request.urlopen(request)</span><br><span class="line">        html &#x3D; response.read().decode(&quot;utf-8&quot;)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e,&quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e,&quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;save......&quot;)</span><br><span class="line">    book &#x3D; xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;,style_compression&#x3D;0)</span><br><span class="line">    sheet &#x3D; book.add_sheet(&#39;电影&#39;,cell_overwrite_ok&#x3D;True)</span><br><span class="line">    col &#x3D; (&quot;影片名&quot;,&quot;评分&quot;,&quot;主演&quot;)</span><br><span class="line">    for i in range(0,3):</span><br><span class="line">        sheet.write(0,i,col[i])</span><br><span class="line">    for i in range(0,100):</span><br><span class="line">        print(&quot;第%d条&quot;%(i+1))</span><br><span class="line">        data &#x3D; datalist[i]</span><br><span class="line">        for j in range(0,3):</span><br><span class="line">            sheet.write(i+1,j,data[j])</span><br><span class="line">    book.save(savepath)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/e70ca014-cca8-485b-90ac-2be128e90384.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>百度贴吧爬取</title>
    <url>/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup  # 网页解析，获取数据</span><br><span class="line">import re  # 正则表达式，进行文字匹配</span><br><span class="line">import urllib.request, urllib.error  # 制定URL，获取网页数据</span><br><span class="line">import xlwt  # 进行excel操作</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url &#x3D; &quot;https:&#x2F;&#x2F;tieba.baidu.com&#x2F;f?kw&#x3D;%E6%AD%A6%E6%B1%89&amp;ie&#x3D;utf-8&amp;pn&#x3D;0&quot;</span><br><span class="line">    html &#x3D; askURL(url)</span><br><span class="line">    soup &#x3D; BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">    for item in soup.find_all(&#39;div&#39;,class_&#x3D; &quot;j_thread_list clearfix&quot;):</span><br><span class="line">        item &#x3D; str(item)</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def askURL(url):</span><br><span class="line">    head &#x3D; &#123;</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36 SLBrowser&#x2F;6.0.1.6181&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    request &#x3D; urllib.request.Request(url, headers&#x3D;head)</span><br><span class="line">    html &#x3D; &quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; urllib.request.urlopen(request)</span><br><span class="line">        html &#x3D; response.read().decode(&quot;utf-8&quot;)</span><br><span class="line">    except urllib.error.URLError as e:</span><br><span class="line">        if hasattr(e, &quot;code&quot;):</span><br><span class="line">            print(e.code)</span><br><span class="line">        if hasattr(e, &quot;reason&quot;):</span><br><span class="line">            print(e.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;爬取完毕！&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/6bb76f0a-a216-46ad-abfc-8362fe248a89.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>国外疫情数据爬取</title>
    <url>/%E5%9B%BD%E5%A4%96%E7%96%AB%E6%83%85%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    divs &#x3D; driver.find_elements_by_xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;foreignWraper&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39;)</span><br><span class="line">    for div in divs:</span><br><span class="line">        area &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;th&#39;).text</span><br><span class="line">        new &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[1]&#39;).text</span><br><span class="line">        total &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[2]&#39;).text</span><br><span class="line">        cured &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[3]&#39;).text</span><br><span class="line">        die &#x3D; div.find_element_by_xpath(&#39;.&#x2F;&#x2F;td[4]&#39;).text</span><br><span class="line">        print(area,new,total,cured,die,sep&#x3D;&#39;|&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    url &#x3D; &#39;https:&#x2F;&#x2F;news.qq.com&#x2F;zt2020&#x2F;page&#x2F;feiyan.htm#&#x2F;global?nojump&#x3D;1&#39;</span><br><span class="line"></span><br><span class="line">    driver &#x3D; webdriver.Chrome()</span><br><span class="line">    driver.get(url)</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020/08/02/94afed6c-883a-4c23-b91c-12d74a85c6b1.png" alt="image.png"><br><img src="/images/2020/08/02/df67da6d-1967-4247-a349-e30d30068795.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取电影天堂磁力链接</title>
    <url>/%E7%88%AC%E5%8F%96%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Time : 2020&#x2F;8&#x2F;2 17:46</span><br><span class="line"># @Author : zc</span><br><span class="line"># @File : 爬取电影天堂磁力链接.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Fri Jul 10 13:17:16 2020</span><br><span class="line">程序功能：可以爬取电影天堂网站所有的电影名称，电影详情，磁力链接</span><br><span class="line">@author: emperor</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"># import re</span><br><span class="line">import bs4</span><br><span class="line">import pandas as pd</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取网页</span><br><span class="line">def getHTMLText(url):</span><br><span class="line">    try:</span><br><span class="line">        headers &#x3D; &#123;&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko&#x2F;20100101 Firefox&#x2F;77.0&#39;&#125;</span><br><span class="line">        r &#x3D; requests.get(url, headers&#x3D;headers, timeout&#x3D;30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding &#x3D; r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except requests.HTTPError as e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(&quot;HTTPError&quot;)</span><br><span class="line">    except requests.RequestException as e:</span><br><span class="line">        print(e)</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;Unknown Error !&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解析网页</span><br><span class="line">def parseHtml(html):</span><br><span class="line">    bsObj &#x3D; bs4.BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    info &#x3D; []  # 储存所有信息</span><br><span class="line">    # 获取电影列表</span><br><span class="line">    tblist &#x3D; bsObj.find_all(&#39;table&#39;, attrs&#x3D;&#123;&#39;class&#39;: &#39;tbspan&#39;&#125;)</span><br><span class="line">    # 对一页里面的每一个电影单独解析处理</span><br><span class="line">    for item in tblist:</span><br><span class="line">        movie &#x3D; []</span><br><span class="line">        link &#x3D; item.b.find_all(&#39;a&#39;)[1]</span><br><span class="line"></span><br><span class="line">        # 获取电影名称</span><br><span class="line">        movie_name &#x3D; link[&quot;title&quot;]</span><br><span class="line"></span><br><span class="line">        # 获取电影详情的url</span><br><span class="line">        url &#x3D; &quot;https:&#x2F;&#x2F;www.dy2018.com&quot; + link[&quot;href&quot;]</span><br><span class="line"></span><br><span class="line">        # 将电影的名称和详情链接放入movie列表</span><br><span class="line">        movie.append(movie_name)</span><br><span class="line">        movie.append(url)</span><br><span class="line">        # print(movie)</span><br><span class="line">        try:</span><br><span class="line">            temp &#x3D; bs4.BeautifulSoup(getHTMLText(url), &quot;html.parser&quot;)  # 解析电影详情页</span><br><span class="line">            tbody &#x3D; temp.find_all(&#39;tbody&#39;)</span><br><span class="line">            # 将电影下载链接放入movie列表</span><br><span class="line">            for i in tbody:</span><br><span class="line">                download &#x3D; i.a.text</span><br><span class="line">                movie.append(download)</span><br><span class="line">            # print(movie)</span><br><span class="line">            # 将电影信息全部放入电影列表中</span><br><span class="line">            info.append(movie)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 储存电影信息</span><br><span class="line">def saveDate(data):</span><br><span class="line">    file_name &#x3D; &#39;电影天堂.csv&#39;  # 可用正则表达式，自动选取名字</span><br><span class="line"></span><br><span class="line">    dataFrame &#x3D; pd.DataFrame(data)</span><br><span class="line">    dataFrame.to_csv(file_name, mode&#x3D;&#39;a&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;, header&#x3D;False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    start_url &#x3D; &quot;https:&#x2F;&#x2F;www.dy2018.com&#x2F;&quot;</span><br><span class="line">    depth &#x3D; 1  # 翻页器，可以自定义翻页数</span><br><span class="line">    style &#x3D; 20  # 不同类型的电影，共20类</span><br><span class="line">    for j in range(style):</span><br><span class="line">        print(&quot;正在爬取第&quot; + str(1 + j) + &quot;类电影信息&quot;)</span><br><span class="line">        first_url &#x3D; start_url + str(1 + j) + &quot;&#x2F;index&quot;</span><br><span class="line">        for i in range(depth):</span><br><span class="line">            print(&quot;正在爬取第&quot; + str(1 + i) + &quot;页电影信息&quot;)</span><br><span class="line">            if i &#x3D;&#x3D; 0:</span><br><span class="line">                url &#x3D; first_url + &quot;.html&quot;  # 处理第一页,可设计处理“1”，实现不同类型的电影爬取</span><br><span class="line">            else:</span><br><span class="line">                url &#x3D; first_url + &quot;_&quot; + str(i * 2) + &quot;.html&quot;  # 翻页</span><br><span class="line">            html &#x3D; getHTMLText(url)</span><br><span class="line">            movies &#x3D; parseHtml(html)</span><br><span class="line">            saveDate(movies)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&#39;爬虫开始启动&#39;)</span><br><span class="line">    start_time &#x3D; datetime.datetime.now()</span><br><span class="line">    main()</span><br><span class="line">    end_time &#x3D; datetime.datetime.now()</span><br><span class="line">    print(&quot;程序总共用时：&#123;:&#125;&quot;.format(end_time - start_time))</span><br><span class="line">    print(&#39;爬取页面结束&#39;)</span><br></pre></td></tr></table></figure>
<p><img src="/images/2020/08/02/f7aed2c6-4faf-4134-9016-12e5cd072e8c.png" alt="image.png"><br><img src="/images/2020/08/02/1b43eb8c-becd-43ea-b22a-cf63ab28a279.png" alt="image.png"><br><img src="/images/2020/08/02/ddf0e025-8810-437d-b4d8-2a2ca1e5da14.png" alt="image.png"><br><img src="/images/2020/08/02/35eb3d08-6046-4e79-a40d-fb458be74000.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
